<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Knight Combat 3D - Endless Survival</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            border: 2px solid #333;
            width: 100vw;
            height: 100vh;
            max-width: 100%;
            max-height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 8px;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            background: #000;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }
        
        .health-bar {
            position: absolute;
            top: max(3vh, 15px);
            width: min(120px, 12vw);
            height: min(16px, 2vh);
            border: 2px solid white;
            background: #333;
        }
        
        .health-fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        .player1-health {
            left: max(1vw, 8px);
        }
        
        .player2-health {
            right: max(1vw, 8px);
        }
        
        .player1-health .health-fill {
            background: #ff6666;
        }
        
        .player2-health .health-fill {
            background: #6666ff;
        }
        
        #gameInfo {
            position: absolute;
            top: max(6vh, 35px);
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: min(14px, 1.8vh);
        }
        
        #controls {
            position: absolute;
            bottom: max(8vh, 40px);
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: min(11px, 1.3vh);
            color: #888;
        }
        
        #touchControls {
            position: absolute;
            bottom: max(15vh, 80px);
            left: max(2vw, 10px);
            pointer-events: auto;
            transform-origin: bottom left;
            z-index: 1000;
        }
        
        #rightControls {
            position: absolute;
            bottom: max(15vh, 80px);
            right: max(2vw, 10px);
            pointer-events: auto;
            transform-origin: bottom right;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: min(10px, 1.5vh);
        }
        
        .touch-btn {
            width: min(60px, 8vw);
            height: min(60px, 8vw);
            border: 2px solid #666;
            background: rgba(255,255,255,0.1);
            color: white;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            display: inline-block;
            text-align: center;
            line-height: min(56px, 7.6vw);
            margin: min(2px, 0.3vw);
            font-size: min(14px, 2vw);
            touch-action: none;
        }
        
        .touch-btn:active,
        .touch-btn.active {
            background: rgba(255,255,255,0.4);
            border-color: #fff;
        }
        
        .joystick-container {
            position: relative;
            width: min(160px, 20vw);
            height: min(160px, 20vw);
            margin-bottom: min(10px, 1.5vh);
            margin: 0 auto min(10px, 1.5vh) auto;
        }
        
        .joystick-base {
            position: relative;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.1);
            border: 2px solid #666;
            border-radius: 50%;
            touch-action: none;
            cursor: pointer;
            user-select: none;
        }
        
        .joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: min(30px, 4vw);
            height: min(30px, 4vw);
            background: rgba(200,200,200,0.9);
            border: 2px solid #fff;
            border-radius: 50%;
            pointer-events: none;
            transition: all 0.1s ease;
        }
        
        .joystick-direction {
            position: absolute;
            background: rgba(255,255,255,0.15);
            border: 1px solid #999;
            color: white;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: min(16px, 2.2vw);
            pointer-events: none;
            opacity: 0.7;
        }
        
        .joystick-up {
            top: min(8px, 1vw);
            left: 50%;
            transform: translateX(-50%);
            width: min(35px, 4.5vw);
            height: min(40px, 5vw);
            border-radius: min(8px, 1vw) min(8px, 1vw) 0 0;
        }
        
        .joystick-down {
            bottom: min(8px, 1vw);
            left: 50%;
            transform: translateX(-50%);
            width: min(35px, 4.5vw);
            height: min(40px, 5vw);
            border-radius: 0 0 min(8px, 1vw) min(8px, 1vw);
        }
        
        .joystick-left {
            left: min(8px, 1vw);
            top: 50%;
            transform: translateY(-50%);
            width: min(40px, 5vw);
            height: min(35px, 4.5vw);
            border-radius: min(8px, 1vw) 0 0 min(8px, 1vw);
        }
        
        .joystick-right {
            right: min(8px, 1vw);
            top: 50%;
            transform: translateY(-50%);
            width: min(40px, 5vw);
            height: min(35px, 4.5vw);
            border-radius: 0 min(8px, 1vw) min(8px, 1vw) 0;
        }
        
        .joystick-up-left {
            top: min(12px, 1.5vw);
            left: min(12px, 1.5vw);
            width: min(25px, 3vw);
            height: min(25px, 3vw);
            border-radius: min(6px, 0.8vw) 0 0 0;
        }
        
        .joystick-up-right {
            top: min(12px, 1.5vw);
            right: min(12px, 1.5vw);
            width: min(25px, 3vw);
            height: min(25px, 3vw);
            border-radius: 0 min(6px, 0.8vw) 0 0;
        }
        
        .joystick-down-left {
            bottom: min(12px, 1.5vw);
            left: min(12px, 1.5vw);
            width: min(25px, 3vw);
            height: min(25px, 3vw);
            border-radius: 0 0 0 min(6px, 0.8vw);
        }
        
        .joystick-down-right {
            bottom: min(12px, 1.5vw);
            right: min(12px, 1.5vw);
            width: min(25px, 3vw);
            height: min(25px, 3vw);
            border-radius: 0 0 min(6px, 0.8vw) 0;
        }
        
        .joystick-direction.active {
            background: rgba(255,255,255,0.4);
            border-color: #fff;
            opacity: 1;
        }
        
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: min(10px, 1.5vh);
            align-items: center;
        }
        
        .flying-controls {
            visibility: visible;
        }
        
        .sound-btn {
            position: absolute;
            top: max(6vh, 35px);
            right: max(1vw, 8px);
            background: rgba(64,64,64,0.8);
            border: 2px solid white;
            color: white;
            padding: min(8px, 1.2vh);
            cursor: pointer;
            pointer-events: auto;
            font-size: min(14px, 2vh);
        }
        
        .menu-btn-ingame {
            position: absolute;
            top: max(8vh, 50px);
            right: max(1vw, 8px);
            background: rgba(64,64,64,0.8);
            border: 2px solid white;
            color: white;
            padding: min(6px, 0.8vh) min(12px, 1.5vw);
            cursor: pointer;
            pointer-events: auto;
            font-size: min(11px, 1.4vh);
        }
        
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            border: 2px solid white;
            padding: min(30px, 4vh);
            text-align: center;
            pointer-events: auto;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        #menu h2 {
            font-size: min(24px, 3vh);
            margin: 0 0 min(20px, 2vh) 0;
        }
        
        #menu p {
            font-size: min(16px, 2vh);
            margin: 0 0 min(20px, 2vh) 0;
        }
        
        .menu-btn {
            background: #333;
            border: 2px solid white;
            color: white;
            padding: min(10px, 1.5vh) min(20px, 3vw);
            margin: min(5px, 0.7vh);
            cursor: pointer;
            font-size: min(14px, 1.8vh);
            display: block;
            width: 100%;
            touch-action: manipulation;
            user-select: none;
        }
        
        .menu-btn:hover,
        .menu-btn:active {
            background: #555;
        }
        
        .difficulty-btn {
            background: #444;
            border: 2px solid #666;
            color: white;
            padding: min(5px, 0.7vh) min(10px, 1.5vw);
            cursor: pointer;
            font-size: min(12px, 1.5vh);
            transition: all 0.2s ease;
            touch-action: manipulation;
            user-select: none;
        }
        
        .difficulty-btn:hover,
        .difficulty-btn:active {
            background: #666;
            border-color: #888;
        }
        
        .difficulty-btn.active {
            background: #0a5c2e;
            border-color: #0f7a37;
            color: #fff;
        }
        
        .hidden {
            display: none;
        }
        
        #gamepadStatus {
            transition: opacity 0.3s ease;
        }
        
        .menu-btn, .difficulty-btn {
            transition: all 0.2s ease;
        }
        
        .menu-btn:focus, .difficulty-btn:focus {
            outline: none;
            box-shadow: 0 0 10px #0f7a37;
            transform: scale(1.05);
        }
        
        #victoryNotification {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            border: 2px solid gold;
            color: gold;
            padding: min(20px, 3vh);
            font-size: min(18px, 2.5vh);
            font-weight: bold;
            text-align: center;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        #victoryNotification.show {
            opacity: 1;
        }
        
        @media (max-width: 768px) {
            #gameContainer {
                padding: 5px;
            }
            
            #touchControls {
                display: block !important;
                bottom: max(20vh, 100px);
                left: max(3vw, 15px);
            }
            
            #rightControls {
                display: block !important;
                bottom: max(20vh, 100px);
                right: max(3vw, 15px);
            }
            
            #controls {
                display: none;
            }
            
            .touch-btn {
                width: min(14vw, 10vh, 60px);
                height: min(14vw, 10vh, 60px);
                line-height: min(13.6vw, 9.6vh, 58px);
                font-size: min(3.5vw, 2.5vh, 16px);
            }
            
            .joystick-container {
                width: min(140px, 18vw);
                height: min(140px, 18vw);
            }
            
            .joystick-knob {
                width: min(25px, 3.5vw);
                height: min(25px, 3.5vw);
            }
        }
        
        @media (max-width: 768px) and (orientation: landscape) {
            #touchControls {
                bottom: max(15vh, 80px);
                left: max(2vw, 10px);
            }
            
            #rightControls {
                bottom: max(15vh, 80px);
                right: max(2vw, 10px);
            }
            
            .touch-btn {
                width: min(8vh, 12vw, 50px);
                height: min(8vh, 12vw, 50px);
                line-height: min(7.6vh, 11.6vw, 48px);
                font-size: min(2vh, 3vw, 14px);
            }
            
            .joystick-container {
                width: min(10vh, 15vw, 120px);
                height: min(10vh, 15vw, 120px);
            }
        }
        
        @media (max-width: 480px) {
            #gameContainer {
                border: 1px solid #333;
                padding: 3px;
            }
            
            #touchControls {
                bottom: max(25vh, 120px);
                left: max(4vw, 20px);
            }
            
            #rightControls {
                bottom: max(25vh, 120px);
                right: max(4vw, 20px);
            }
            
            .touch-btn {
                width: min(16vw, 8vh, 50px);
                height: min(16vw, 8vh, 50px);
                line-height: min(15.6vw, 7.6vh, 48px);
                font-size: min(4vw, 2vh, 14px);
            }
            
            .joystick-container {
                width: min(120px, 22vw);
                height: min(120px, 22vw);
            }
            
            .joystick-knob {
                width: min(20px, 3vw);
                height: min(20px, 3vw);
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui">
            <div class="health-bar player1-health">
                <div class="health-fill" id="player1Health" style="width: 100%"></div>
            </div>
            <div class="health-bar player2-health">
                <div class="health-fill" id="player2Health" style="width: 100%"></div>
            </div>
            
            <div id="victoryNotification">
                ENEMY DEFEATED!<br>
                <span id="continuingText">Continuing with current health...</span>
            </div>
            
            <div id="gameInfo">
                <div id="gameMode">ENDLESS SURVIVAL - Flying Combat</div>
                <div id="gameStatus">Current: 0 | High Score: 0 | Total Wins: 0 | Losses: 0</div>
            </div>
            
            <div id="controls">
                WASD: Move | F: Attack | G: Block | E: Fly Up | Q: Fly Down | M: Menu | P: Pause<br>
                Gamepad: Left Stick/D-Pad: Move/Navigate | A: Attack/Select | B: Block/Back | Y: Fly Up | X: Fly Down | RT/LT: Fly | Start: Menu
            </div>
            
            <div id="touchControls">
                <div class="joystick-container">
                    <div class="joystick-base" id="joystickBase">
                        <div class="joystick-direction joystick-up">‚Üë</div>
                        <div class="joystick-direction joystick-up-right">‚Üó</div>
                        <div class="joystick-direction joystick-right">‚Üí</div>
                        <div class="joystick-direction joystick-down-right">‚Üò</div>
                        <div class="joystick-direction joystick-down">‚Üì</div>
                        <div class="joystick-direction joystick-down-left">‚Üô</div>
                        <div class="joystick-direction joystick-left">‚Üê</div>
                        <div class="joystick-direction joystick-up-left">‚Üñ</div>
                        <div class="joystick-knob" id="joystickKnob"></div>
                    </div>
                </div>
            </div>
            
            <div id="rightControls">
                <div class="action-buttons">
                    <div style="display: flex; gap: min(10px, 1.5vh); align-items: center; margin-bottom: min(10px, 1.5vh);">
                        <div class="touch-btn flying-controls" id="flyingUp" data-key="e" style="background: rgba(0,150,0,0.8);">‚¨Ü FLY</div>
                        <div class="touch-btn" data-key="f" style="background: rgba(150,0,0,0.8);">ATK</div>
                    </div>
                    <div style="display: flex; gap: min(10px, 1.5vh); align-items: center;">
                        <div class="touch-btn flying-controls" id="flyingDown" data-key="q" style="background: rgba(150,100,0,0.8);">‚¨á FLY</div>
                        <div class="touch-btn" data-key="g" style="background: rgba(0,0,150,0.8);">BLK</div>
                    </div>
                </div>
            </div>
            
            <div class="sound-btn" id="soundButton">üîá</div>
            <div class="menu-btn-ingame" id="menuButton" style="display: none;">MENU</div>
        </div>
        
        <div id="menu">
            <h2>KNIGHT COMBAT 3D</h2>
            <p>Endless Survival Mode</p>
            <div id="mainMenuButtons">
                <div class="menu-btn" data-action="startGame" data-mode="flying" data-multiplayer="false">START ENDLESS SURVIVAL</div>
                <br>
                <div style="margin: min(20px, 2vh) 0;">
                    <div style="font-size: min(16px, 2vh); margin-bottom: min(10px, 1vh); color: #ccc;">AI Difficulty:</div>
                    <div style="display: flex; flex-wrap: wrap; gap: min(5px, 0.5vh); justify-content: center;">
                        <div class="difficulty-btn" data-difficulty="very_easy">Very Easy</div>
                        <div class="difficulty-btn" data-difficulty="easy">Easy</div>
                        <div class="difficulty-btn active" data-difficulty="normal">Normal</div>
                        <div class="difficulty-btn" data-difficulty="hard">Hard</div>
                        <div class="difficulty-btn" data-difficulty="very_hard">Very Hard</div>
                    </div>
                </div>
                <div class="menu-btn" data-action="showGamepadInfo">Gamepad Info</div>
                <div class="menu-btn" data-action="exitGame">Exit Game</div>
            </div>
            <div id="pauseMenuButtons" class="hidden">
                <div class="menu-btn" data-action="resumeGame">Resume Game</div>
                <div class="menu-btn" data-action="restartGame">Restart Game</div>
                <div class="menu-btn" data-action="backToMainMenu">Main Menu</div>
            </div>
        </div>
    </div>

    <script>
        // State Preservation System for Android Orientation Protection
        class StateManager {
            constructor() {
                this.savedState = null;
                this.preservationActive = false;
            }
            
            saveState(game) {
                if (!game || !game.player || !game.enemy) return;
                
                console.log('Saving game state before orientation change...');
                
                this.savedState = {
                    gameState: game.gameState,
                    gameMode: game.gameMode,
                    multiplayer: game.multiplayer,
                    difficulty: game.difficulty,
                    currentStreak: game.currentStreak,
                    highScore: game.highScore,
                    totalWins: game.totalWins,
                    totalLosses: game.totalLosses,
                    gameTime: game.gameTime,
                    victoryNotificationTimer: game.victoryNotificationTimer,
                    nextEnemyTimer: game.nextEnemyTimer,
                    roundVictoryDelay: game.roundVictoryDelay,
                    player: this.serializeCharacter(game.player),
                    enemy: this.serializeCharacter(game.enemy),
                    cameraPos: {
                        x: game.cameraPos.x,
                        y: game.cameraPos.y,
                        z: game.cameraPos.z
                    },
                    cameraAngle: game.cameraAngle
                };
                
                this.preservationActive = true;
                console.log('Game state saved successfully');
            }
            
            restoreState(game) {
                if (!this.savedState || !this.preservationActive) return false;
                
                console.log('Restoring game state after orientation change...');
                
                try {
                    game.gameState = this.savedState.gameState;
                    game.gameMode = this.savedState.gameMode;
                    game.multiplayer = this.savedState.multiplayer;
                    game.difficulty = this.savedState.difficulty;
                    game.currentStreak = this.savedState.currentStreak;
                    game.highScore = this.savedState.highScore;
                    game.totalWins = this.savedState.totalWins;
                    game.totalLosses = this.savedState.totalLosses;
                    game.gameTime = this.savedState.gameTime;
                    game.victoryNotificationTimer = this.savedState.victoryNotificationTimer;
                    game.nextEnemyTimer = this.savedState.nextEnemyTimer;
                    game.roundVictoryDelay = this.savedState.roundVictoryDelay;
                    
                    game.cameraPos = new Vector3(
                        this.savedState.cameraPos.x,
                        this.savedState.cameraPos.y,
                        this.savedState.cameraPos.z
                    );
                    game.cameraAngle = this.savedState.cameraAngle;
                    
                    game.player = this.deserializeCharacter(this.savedState.player, true);
                    game.enemy = this.deserializeCharacter(this.savedState.enemy, false);
                    
                    game.updateHealthBars();
                    game.updateGameStatus();
                    
                    if (game.gameState === "main_menu") {
                        game.showMainMenu();
                        document.getElementById('menu').classList.remove('hidden');
                        document.getElementById('menuButton').style.display = 'none';
                    } else if (game.gameState === "paused") {
                        game.showPauseMenu();
                        document.getElementById('menu').classList.remove('hidden');
                        document.getElementById('menuButton').style.display = 'block';
                    } else if (game.gameState === "playing") {
                        document.getElementById('menu').classList.add('hidden');
                        document.getElementById('menuButton').style.display = 'block';
                    }
                    
                    if (game.victoryNotificationTimer > 0) {
                        game.showVictoryNotification();
                    }
                    
                    console.log('Game state restored successfully');
                    this.preservationActive = false;
                    return true;
                } catch (error) {
                    console.error('Failed to restore game state:', error);
                    this.preservationActive = false;
                    return false;
                }
            }
            
            serializeCharacter(char) {
                if (!char) return null;
                
                return {
                    pos: { x: char.pos.x, y: char.pos.y, z: char.pos.z },
                    color: char.color,
                    isPlayer: char.isPlayer,
                    playerId: char.playerId,
                    flyingEnabled: char.flyingEnabled,
                    flying: char.flying,
                    health: char.health,
                    maxHealth: char.maxHealth,
                    state: char.state,
                    stateTimer: char.stateTimer,
                    attackCooldown: char.attackCooldown,
                    blockCooldown: char.blockCooldown,
                    facing: { x: char.facing.x, y: char.facing.y, z: char.facing.z },
                    lockedFacing: char.lockedFacing ? { x: char.lockedFacing.x, y: char.lockedFacing.y, z: char.lockedFacing.z } : null,
                    velocity: { x: char.velocity.x, y: char.velocity.y, z: char.velocity.z },
                    moveSpeed: char.moveSpeed,
                    attackRange: char.attackRange,
                    bodyRadius: char.bodyRadius,
                    hitConnected: char.hitConnected,
                    damageFlashTimer: char.damageFlashTimer,
                    blockFlashTimer: char.blockFlashTimer,
                    attackBlockedFlashTimer: char.attackBlockedFlashTimer,
                    attackPressed: char.attackPressed,
                    blockPressed: char.blockPressed,
                    gravity: char.gravity,
                    groundLevel: char.groundLevel
                };
            }
            
            deserializeCharacter(data, isPlayer) {
                if (!data) return null;
                
                const char = new Character(
                    new Vector3(data.pos.x, data.pos.y, data.pos.z),
                    data.color,
                    data.isPlayer,
                    data.flyingEnabled,
                    isPlayer ? 'normal' : game.difficulty,
                    data.playerId
                );
                
                char.flying = data.flying;
                char.health = data.health;
                char.maxHealth = data.maxHealth;
                char.state = data.state;
                char.stateTimer = data.stateTimer;
                char.attackCooldown = data.attackCooldown;
                char.blockCooldown = data.blockCooldown;
                char.facing = new Vector3(data.facing.x, data.facing.y, data.facing.z);
                char.lockedFacing = data.lockedFacing ? new Vector3(data.lockedFacing.x, data.lockedFacing.y, data.lockedFacing.z) : null;
                char.velocity = new Vector3(data.velocity.x, data.velocity.y, data.velocity.z);
                char.moveSpeed = data.moveSpeed;
                char.attackRange = data.attackRange;
                char.bodyRadius = data.bodyRadius;
                char.hitConnected = data.hitConnected;
                char.damageFlashTimer = data.damageFlashTimer;
                char.blockFlashTimer = data.blockFlashTimer;
                char.attackBlockedFlashTimer = data.attackBlockedFlashTimer;
                char.attackPressed = data.attackPressed;
                char.blockPressed = data.blockPressed;
                char.gravity = data.gravity;
                char.groundLevel = data.groundLevel;
                
                return char;
            }
            
            clearState() {
                this.savedState = null;
                this.preservationActive = false;
            }
        }
        
        // Enhanced Gamepad Controller System
        class GamepadController {
            constructor(game) {
                this.game = game;
                this.gamepadIndex = -1;
                this.gamepadIndex2 = -1;
                
                this.buttonStates = new Map();
                this.axisStates = new Map();
                this.lastFrameTime = 0;
                this.frameCount = 0;
                
                this.deadzone = 0.2;
                this.debugMode = false;
                
                this.selectedMenuIndex = 0;
                this.menuItems = [];
                this.menuNavigationCooldown = 0;
                this.buttonPressCooldown = 0;
                
                this.gamepadState = {
                    player1: {
                        movement: { x: 0, y: 0 },
                        flying: { up: false, down: false },
                        combat: { attack: false, block: false },
                        menu: { open: false, select: false, back: false }
                    },
                    player2: {
                        movement: { x: 0, y: 0 },
                        flying: { up: false, down: false },
                        combat: { attack: false, block: false },
                        menu: { open: false, select: false, back: false }
                    }
                };
                
                this.setupEventListeners();
                this.isActive = true;
                this.startPolling();
                this.updateGamepadStatus();
            }
            
            setupEventListeners() {
                window.addEventListener('gamepadconnected', (e) => {
                    console.log(`Gamepad connected: ${e.gamepad.id}`);
                    console.log(`   Index: ${e.gamepad.index}, Buttons: ${e.gamepad.buttons.length}, Axes: ${e.gamepad.axes.length}`);
                    
                    this.buttonStates.set(e.gamepad.index, new Array(e.gamepad.buttons.length).fill(false));
                    this.axisStates.set(e.gamepad.index, new Array(e.gamepad.axes.length).fill(0));
                    
                    if (this.gamepadIndex === -1) {
                        this.gamepadIndex = e.gamepad.index;
                        this.showGamepadStatus(`Player 1: ${this.getControllerName(e.gamepad.id)}`, true);
                    } else if (this.gamepadIndex2 === -1 && e.gamepad.index !== this.gamepadIndex) {
                        this.gamepadIndex2 = e.gamepad.index;
                        this.showGamepadStatus(`Player 2: ${this.getControllerName(e.gamepad.id)}`, true);
                    }
                    
                    this.updateGamepadStatus();
                    this.updateMenuItems();
                });
                
                window.addEventListener('gamepaddisconnected', (e) => {
                    console.log(`Gamepad disconnected: ${e.gamepad.id}`);
                    
                    this.buttonStates.delete(e.gamepad.index);
                    this.axisStates.delete(e.gamepad.index);
                    
                    if (this.gamepadIndex === e.gamepad.index) {
                        this.gamepadIndex = -1;
                        this.resetPlayerState(1);
                    }
                    if (this.gamepadIndex2 === e.gamepad.index) {
                        this.gamepadIndex2 = -1;
                        this.resetPlayerState(2);
                    }
                    
                    this.updateGamepadStatus();
                });
            }
            
            resetPlayerState(playerNum) {
                const state = playerNum === 1 ? this.gamepadState.player1 : this.gamepadState.player2;
                state.movement = { x: 0, y: 0 };
                state.flying = { up: false, down: false };
                state.combat = { attack: false, block: false };
                state.menu = { open: false, select: false, back: false };
            }
            
            getControllerName(id) {
                id = id.toLowerCase();
                if (id.includes('xbox')) return 'Xbox Controller';
                if (id.includes('playstation') || id.includes('ps4') || id.includes('ps5')) return 'PlayStation Controller';
                if (id.includes('nintendo')) return 'Nintendo Controller';
                if (id.includes('steam')) return 'Steam Controller';
                return 'Generic Gamepad';
            }
            
            updateGamepadStatus() {
                const connected = this.getConnectedCount();
                if (connected === 0) {
                    this.showGamepadStatus('No gamepads detected', false);
                } else {
                    this.showGamepadStatus(`${connected} gamepad${connected > 1 ? 's' : ''} connected`, true);
                }
            }
            
            showGamepadStatus(message, connected) {
                let statusEl = document.getElementById('gamepadStatus');
                if (!statusEl) {
                    statusEl = document.createElement('div');
                    statusEl.id = 'gamepadStatus';
                    statusEl.style.cssText = `
                        position: absolute;
                        bottom: max(3vh, 15px);
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(0,0,0,0.9);
                        border: 2px solid ${connected ? '#0f7a37' : '#666'};
                        color: ${connected ? '#0f7a37' : '#888'};
                        padding: min(8px, 1vh) min(12px, 2vw);
                        font-size: min(11px, 1.4vh);
                        pointer-events: none;
                        z-index: 1000;
                        border-radius: 4px;
                        font-weight: bold;
                    `;
                    document.getElementById('ui').appendChild(statusEl);
                }
                statusEl.textContent = `üéÆ ${message}`;
                statusEl.style.borderColor = connected ? '#0f7a37' : '#666';
                statusEl.style.color = connected ? '#0f7a37' : '#888';
                
                setTimeout(() => {
                    if (statusEl && statusEl.parentNode) {
                        statusEl.style.opacity = '0.3';
                    }
                }, 3000);
            }
            
            startPolling() {
                const poll = (timestamp) => {
                    if (!this.isActive) return;
                    
                    try {
                        this.frameCount++;
                        const deltaTime = timestamp - this.lastFrameTime;
                        this.lastFrameTime = timestamp;
                        
                        if (this.debugMode && this.frameCount % 60 === 0) {
                            console.log(`Frame ${this.frameCount}, Delta: ${deltaTime.toFixed(1)}ms`);
                            console.log(`Active gamepads: P1=${this.gamepadIndex}, P2=${this.gamepadIndex2}`);
                        }
                        
                        this.menuNavigationCooldown = Math.max(0, this.menuNavigationCooldown - 1);
                        this.buttonPressCooldown = Math.max(0, this.buttonPressCooldown - 1);
                        
                        const gamepads = navigator.getGamepads();
                        if (!gamepads) {
                            requestAnimationFrame(poll);
                            return;
                        }
                        
                        const preserveMenuStates = this.game.gameState === "main_menu" || this.game.gameState === "paused";
                        if (!preserveMenuStates) {
                            this.resetPlayerState(1);
                            this.resetPlayerState(2);
                        } else {
                            this.gamepadState.player1.movement = { x: 0, y: 0 };
                            this.gamepadState.player1.flying = { up: false, down: false };
                            this.gamepadState.player1.combat = { attack: false, block: false };
                            this.gamepadState.player2.movement = { x: 0, y: 0 };
                            this.gamepadState.player2.flying = { up: false, down: false };
                            this.gamepadState.player2.combat = { attack: false, block: false };
                        }
                        
                        if (this.gamepadIndex !== -1 && gamepads[this.gamepadIndex]) {
                            this.updateGamepadState(gamepads[this.gamepadIndex], 1);
                        }
                        
                        if (this.gamepadIndex2 !== -1 && gamepads[this.gamepadIndex2]) {
                            this.updateGamepadState(gamepads[this.gamepadIndex2], 2);
                        }
                        
                        this.applyGamepadInput();
                        
                        this.gamepadState.player1.menu = { open: false, select: false, back: false };
                        this.gamepadState.player2.menu = { open: false, select: false, back: false };
                        
                    } catch (error) {
                        console.error('Gamepad polling error:', error);
                        if (this.debugMode) {
                            console.trace('Error stack trace');
                        }
                    }
                    
                    requestAnimationFrame(poll);
                };
                
                requestAnimationFrame(poll);
            }
            
            updateGamepadState(gamepad, playerNum) {
                if (!gamepad || !gamepad.connected) return;
                
                const playerState = playerNum === 1 ? this.gamepadState.player1 : this.gamepadState.player2;
                const lastButtonStates = this.buttonStates.get(gamepad.index) || [];
                const lastAxisStates = this.axisStates.get(gamepad.index) || [];
                
                if (lastButtonStates.length !== gamepad.buttons.length) {
                    this.buttonStates.set(gamepad.index, new Array(gamepad.buttons.length).fill(false));
                }
                if (lastAxisStates.length !== gamepad.axes.length) {
                    this.axisStates.set(gamepad.index, new Array(gamepad.axes.length).fill(0));
                }
                
                // Analog sticks
                if (gamepad.axes.length >= 2) {
                    const leftStickX = gamepad.axes[0];
                    const leftStickY = gamepad.axes[1];
                    
                    playerState.movement.x = Math.abs(leftStickX) > this.deadzone ? leftStickX : 0;
                    playerState.movement.y = Math.abs(leftStickY) > this.deadzone ? leftStickY : 0;
                    
                    if (this.debugMode && (Math.abs(leftStickX) > 0.1 || Math.abs(leftStickY) > 0.1)) {
                        console.log(`P${playerNum} Movement: X=${leftStickX.toFixed(2)}, Y=${leftStickY.toFixed(2)}`);
                    }
                }
                
                // Right stick for flying - ENHANCED
                if (gamepad.axes.length >= 4 && playerNum === 1 && this.game.gameMode === "flying") {
                    const rightStickY = gamepad.axes[3];
                    if (this.debugMode && Math.abs(rightStickY) > 0.1) {
                        console.log(`P${playerNum} Right Stick Y: ${rightStickY.toFixed(2)} (flying mode)`);
                    }
                    if (Math.abs(rightStickY) > this.deadzone) {
                        if (rightStickY < -this.deadzone) {
                            playerState.flying.up = true;
                            if (this.debugMode) console.log(`P${playerNum} Right stick - FLY UP!`);
                        }
                        if (rightStickY > this.deadzone) {
                            playerState.flying.down = true;
                            if (this.debugMode) console.log(`P${playerNum} Right stick - FLY DOWN!`);
                        }
                    }
                }
                
                // Enhanced trigger detection
                if (gamepad.axes.length >= 6) {
                    let leftTrigger = 0, rightTrigger = 0;
                    
                    if (gamepad.axes[2] !== undefined) leftTrigger = Math.max(0, gamepad.axes[2]);
                    if (gamepad.axes[5] !== undefined) rightTrigger = Math.max(0, gamepad.axes[5]);
                    
                    if (leftTrigger === 0 && gamepad.axes[4] !== undefined) {
                        leftTrigger = Math.max(0, gamepad.axes[4]);
                    }
                    if (rightTrigger === 0 && gamepad.axes[3] !== undefined && gamepad.axes.length > 5) {
                        rightTrigger = Math.max(0, gamepad.axes[3]);
                    }
                    
                    if (this.game.gameMode === "flying" && this.debugMode && (leftTrigger > 0.1 || rightTrigger > 0.1)) {
                        console.log(`P${playerNum} Triggers - LT: ${leftTrigger.toFixed(2)}, RT: ${rightTrigger.toFixed(2)}`);
                    }
                    
                    if (this.game.gameMode === "flying") {
                        if (leftTrigger > 0.3) {
                            playerState.flying.down = true;
                            if (this.debugMode) console.log(`P${playerNum} Left trigger - FLY DOWN!`);
                        }
                        if (rightTrigger > 0.3) {
                            playerState.flying.up = true;
                            if (this.debugMode) console.log(`P${playerNum} Right trigger - FLY UP!`);
                        }
                    }
                }
                
                // Enhanced button handling with comprehensive flying controls
                for (let i = 0; i < gamepad.buttons.length; i++) {
                    const button = gamepad.buttons[i];
                    const pressed = button.pressed || button.value > 0.5;
                    const wasPressed = lastButtonStates[i] || false;
                    
                    lastButtonStates[i] = pressed;
                    
                    if (pressed) {
                        if (this.debugMode && pressed && !wasPressed) {
                            console.log(`P${playerNum} Button ${i} pressed (flying mode: ${this.game.gameMode === "flying"})`);
                        }
                        
                        switch (i) {
                            case 0: // A button
                                playerState.combat.attack = true;
                                if (!wasPressed) playerState.menu.select = true;
                                break;
                            case 1: // B button
                                playerState.combat.block = true;
                                if (!wasPressed) playerState.menu.back = true;
                                break;
                            case 2: // X button - Fly Down
                                if (this.game.gameMode === "flying") {
                                    playerState.flying.down = true;
                                    if (this.debugMode || !wasPressed) {
                                        console.log(`P${playerNum} X button - FLY DOWN activated!`);
                                    }
                                }
                                break;
                            case 3: // Y button - Fly Up
                                if (this.game.gameMode === "flying") {
                                    playerState.flying.up = true;
                                    if (this.debugMode || !wasPressed) {
                                        console.log(`P${playerNum} Y button - FLY UP activated!`);
                                    }
                                }
                                break;
                            case 4: // LB - Block + Fly Down
                                playerState.combat.block = true;
                                if (this.game.gameMode === "flying") {
                                    playerState.flying.down = true;
                                    if (this.debugMode) console.log(`P${playerNum} LB - FLY DOWN (alt)!`);
                                }
                                break;
                            case 5: // RB - Attack + Fly Up
                                playerState.combat.attack = true;
                                if (this.game.gameMode === "flying") {
                                    playerState.flying.up = true;
                                    if (this.debugMode) console.log(`P${playerNum} RB - FLY UP (alt)!`);
                                }
                                break;
                            case 6: // LT button - Fly Down
                                if (this.game.gameMode === "flying") {
                                    playerState.flying.down = true;
                                    if (this.debugMode) console.log(`P${playerNum} LT button - FLY DOWN!`);
                                }
                                break;
                            case 7: // RT button - Fly Up
                                if (this.game.gameMode === "flying") {
                                    playerState.flying.up = true;
                                    if (this.debugMode) console.log(`P${playerNum} RT button - FLY UP!`);
                                }
                                break;
                            case 8: // Select/Back button
                                if (!wasPressed) playerState.menu.back = true;
                                break;
                            case 9: // Start/Menu button
                                if (!wasPressed) playerState.menu.open = true;
                                break;
                            case 10: // Left stick click - Fly down
                                if (this.game.gameMode === "flying") {
                                    playerState.flying.down = true;
                                    if (this.debugMode) console.log(`P${playerNum} L3 click - FLY DOWN!`);
                                }
                                break;
                            case 11: // Right stick click - Fly up
                                if (this.game.gameMode === "flying") {
                                    playerState.flying.up = true;
                                    if (this.debugMode) console.log(`P${playerNum} R3 click - FLY UP!`);
                                }
                                break;
                            case 12: // D-pad up
                                playerState.movement.y = -1;
                                if (this.game.gameMode === "flying") {
                                    playerState.flying.up = true;
                                    if (this.debugMode) console.log(`P${playerNum} D-pad up - FLY UP!`);
                                }
                                break;
                            case 13: // D-pad down
                                playerState.movement.y = 1;
                                if (this.game.gameMode === "flying") {
                                    playerState.flying.down = true;
                                    if (this.debugMode) console.log(`P${playerNum} D-pad down - FLY DOWN!`);
                                }
                                break;
                            case 14: // D-pad left
                                playerState.movement.x = -1;
                                break;
                            case 15: // D-pad right
                                playerState.movement.x = 1;
                                break;
                            default:
                                if (this.debugMode && pressed && !wasPressed) {
                                    console.log(`P${playerNum} Unmapped button ${i} pressed - trying as fly control`);
                                }
                                if (this.game.gameMode === "flying" && i > 15) {
                                    if (i % 2 === 0) {
                                        playerState.flying.down = true;
                                        if (this.debugMode) console.log(`P${playerNum} Button ${i} - FLY DOWN (auto-map)!`);
                                    } else {
                                        playerState.flying.up = true;
                                        if (this.debugMode) console.log(`P${playerNum} Button ${i} - FLY UP (auto-map)!`);
                                    }
                                }
                                break;
                        }
                    }
                }
                
                this.buttonStates.set(gamepad.index, lastButtonStates);
                this.axisStates.set(gamepad.index, lastAxisStates);
            }
            
            applyGamepadInput() {
                this.handleMenuInput();
                
                if (this.game.gameState === "playing") {
                    this.applyGameInput();
                }
            }
            
            handleMenuInput() {
                if (this.game.gameState !== "main_menu" && this.game.gameState !== "paused") {
                    if (this.gamepadState.player1.menu.open) {
                        if (this.game.gameState === "playing") {
                            this.game.togglePause();
                            this.updateMenuItems();
                        } else if (this.game.gameState === "paused") {
                            this.game.resumeGame();
                        }
                    }
                    return;
                }
                
                this.updateMenuItems();
                
                if (this.menuNavigationCooldown === 0) {
                    if (this.gamepadState.player1.movement.y < -0.3) {
                        this.selectedMenuIndex = (this.selectedMenuIndex - 1 + this.menuItems.length) % this.menuItems.length;
                        this.highlightSelectedMenuItem();
                        this.menuNavigationCooldown = 10;
                    } else if (this.gamepadState.player1.movement.y > 0.3) {
                        this.selectedMenuIndex = (this.selectedMenuIndex + 1) % this.menuItems.length;
                        this.highlightSelectedMenuItem();
                        this.menuNavigationCooldown = 10;
                    }
                }
                
                if (this.buttonPressCooldown === 0) {
                    if (this.gamepadState.player1.menu.select) {
                        if (this.menuItems[this.selectedMenuIndex]) {
                            const selectedItem = this.menuItems[this.selectedMenuIndex];
                            console.log(`Menu item selected: "${selectedItem.textContent.trim()}"`);
                            
                            try {
                                selectedItem.click();
                            } catch (e) {
                                const action = selectedItem.dataset.action;
                                const mode = selectedItem.dataset.mode;
                                const multiplayer = selectedItem.dataset.multiplayer === 'true';
                                const difficulty = selectedItem.dataset.difficulty;
                                
                                if (action === 'startGame') {
                                    this.game.startEndlessGame();
                                } else if (action === 'resumeGame') {
                                    this.game.resumeGame();
                                } else if (action === 'restartGame') {
                                    this.game.restartGame();
                                } else if (action === 'backToMainMenu') {
                                    this.game.backToMainMenu();
                                } else if (action === 'showGamepadInfo') {
                                    this.game.showGamepadInfo();
                                } else if (action === 'exitGame') {
                                    this.game.exitGame();
                                } else if (difficulty) {
                                    this.game.setDifficulty(difficulty);
                                }
                            }
                            
                            this.buttonPressCooldown = 20;
                        }
                    }
                    
                    if (this.gamepadState.player1.menu.back) {
                        if (this.game.gameState === "paused") {
                            this.game.resumeGame();
                            this.buttonPressCooldown = 20;
                        }
                    }
                }
            }
            
            applyGameInput() {
                const gamepadKeys = new Set(['w', 'a', 's', 'd', 'f', 'g', 'e', 'q', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'k', 'l', 'i', 'o']);
                
                gamepadKeys.forEach(key => {
                    if (!this.game.keyboardKeysPressed.has(key) && 
                        !this.game.touchKeysPressed.has(key) && 
                        !this.game.joystickKeysPressed.has(key)) {
                        this.game.keysPressed.delete(key);
                    }
                });
                
                this.applyPlayerInput(1, this.gamepadState.player1);
                
                if (this.game.multiplayer && this.gamepadIndex2 !== -1) {
                    this.applyPlayerInput(2, this.gamepadState.player2);
                }
                
                this.game.keyboardKeysPressed.forEach(key => {
                    this.game.keysPressed.add(key);
                });
            }
            
            applyPlayerInput(playerNum, state) {
                const keyMap = playerNum === 1 ? {
                    moveLeft: 'a', moveRight: 'd', moveUp: 'w', moveDown: 's',
                    attack: 'f', block: 'g', flyUp: 'e', flyDown: 'q'
                } : {
                    moveLeft: 'arrowleft', moveRight: 'arrowright', moveUp: 'arrowup', moveDown: 'arrowdown',
                    attack: 'k', block: 'l', flyUp: 'i', flyDown: 'o'
                };
                
                if (state.movement.x < -this.deadzone) this.game.keysPressed.add(keyMap.moveLeft);
                if (state.movement.x > this.deadzone) this.game.keysPressed.add(keyMap.moveRight);
                if (state.movement.y < -this.deadzone) this.game.keysPressed.add(keyMap.moveUp);
                if (state.movement.y > this.deadzone) this.game.keysPressed.add(keyMap.moveDown);
                
                if (state.combat.attack) this.game.keysPressed.add(keyMap.attack);
                if (state.combat.block) this.game.keysPressed.add(keyMap.block);
                
                if (state.flying.up) this.game.keysPressed.add(keyMap.flyUp);
                if (state.flying.down) this.game.keysPressed.add(keyMap.flyDown);
            }
            
            updateMenuItems() {
                this.menuItems = [];
                const visibleMenus = document.querySelectorAll('#mainMenuButtons:not(.hidden) .menu-btn, #pauseMenuButtons:not(.hidden) .menu-btn, .difficulty-btn:not(.hidden)');
                this.menuItems = Array.from(visibleMenus);
                
                if (this.selectedMenuIndex >= this.menuItems.length) {
                    this.selectedMenuIndex = 0;
                }
                
                this.highlightSelectedMenuItem();
            }
            
            highlightSelectedMenuItem() {
                this.menuItems.forEach(item => {
                    item.style.boxShadow = '';
                    item.style.transform = '';
                });
                
                if (this.menuItems[this.selectedMenuIndex]) {
                    this.menuItems[this.selectedMenuIndex].style.boxShadow = '0 0 10px #0f7a37';
                    this.menuItems[this.selectedMenuIndex].style.transform = 'scale(1.05)';
                }
            }
            
            hasGamepad() {
                const gamepads = navigator.getGamepads();
                return this.gamepadIndex !== -1 && gamepads && gamepads[this.gamepadIndex] && gamepads[this.gamepadIndex].connected;
            }
            
            getConnectedCount() {
                const gamepads = navigator.getGamepads();
                let count = 0;
                if (gamepads) {
                    for (let i = 0; i < gamepads.length; i++) {
                        if (gamepads[i] && gamepads[i].connected) {
                            count++;
                        }
                    }
                }
                return count;
            }
            
            enableDebugMode() {
                this.debugMode = true;
                console.log('ENHANCED FLYING DEBUG MODE ENABLED');
                console.log('========================================');
                console.log('ALL button presses will be logged with indices');
                console.log('Look for "FLY UP/DOWN activated!" messages');
                console.log('Expected mapping:');
                console.log('  Button 0 = A, Button 1 = B');
                console.log('  Button 2 = X (Fly Down), Button 3 = Y (Fly Up)');
                console.log('  RT/LT triggers and right stick also work');
                console.log('========================================');
            }
            
            disableDebugMode() {
                this.debugMode = false;
            }
            
            destroy() {
                this.isActive = false;
                this.buttonStates.clear();
                this.axisStates.clear();
                this.resetPlayerState(1);
                this.resetPlayerState(2);
            }
        }
        
        // Audio Manager
        class AudioManager {
            constructor() {
                this.muted = true;
                this.audioContext = null;
                this.initialized = false;
                this.initPromise = null;
                this.pendingSounds = [];
                
                const initHandler = () => this.initAudio();
                document.addEventListener('click', initHandler, { once: true });
                document.addEventListener('keydown', initHandler, { once: true });
                document.addEventListener('touchstart', initHandler, { once: true });
            }
            
            async initAudio() {
                if (this.initialized || this.initPromise) return this.initPromise;
                
                this.initPromise = new Promise(resolve => {
                    try {
                        if (!window.AudioContext && !window.webkitAudioContext) {
                            console.warn('Web Audio API not supported');
                            resolve();
                            return;
                        }
                        
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        
                        if (this.audioContext.state === 'suspended') {
                            this.audioContext.resume().then(() => {
                                this.initialized = true;
                                console.log('Audio system initialized');
                                this.processPendingSounds();
                                resolve();
                            }).catch(e => {
                                console.warn('Audio resume failed:', e);
                                resolve();
                            });
                        } else {
                            this.initialized = true;
                            console.log('Audio system initialized');
                            this.processPendingSounds();
                            resolve();
                        }
                    } catch (e) {
                        console.warn('Audio initialization failed:', e);
                        resolve();
                    }
                });
                
                return this.initPromise;
            }
            
            processPendingSounds() {
                this.pendingSounds.forEach(soundType => {
                    this.playSound(soundType);
                });
                this.pendingSounds = [];
            }
            
            async playSound(soundType) {
                if (this.muted) return;
                
                if (!this.initialized) {
                    this.pendingSounds.push(soundType);
                    await this.initAudio();
                    return;
                }
                
                if (!this.audioContext) return;
                
                try {
                    const patterns = {
                        'player_attack': 1,
                        'player_block': 2,
                        'player_hit_enemy': 1,
                        'player_take_damage': 3,
                        'player_victory': 4,
                        'player_defeat': 5,
                        'enemy_attack': 1,
                        'enemy_block': 2,
                        'enemy_hit_player': 1,
                        'enemy_take_damage': 3,
                        'round_victory': 3,
                    };
                    
                    const beepCount = patterns[soundType] || 1;
                    this.playBeepPattern(beepCount);
                } catch (e) {
                    console.warn('Sound playback error:', e);
                }
            }
            
            playBeepPattern(count) {
                for (let i = 0; i < count; i++) {
                    setTimeout(() => this.playBeep(), i * 100);
                }
            }
            
            playBeep() {
                if (!this.audioContext || this.audioContext.state !== 'running') return;
                
                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(440, this.audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.1);
                } catch (e) {
                    console.warn('Beep playback error:', e);
                }
            }
            
            toggleMute() {
                this.muted = !this.muted;
                return this.muted;
            }
        }
        
        // Joystick Controller
        class JoystickController {
            constructor(game) {
                this.game = game;
                this.joystickBase = document.getElementById('joystickBase');
                this.joystickKnob = document.getElementById('joystickKnob');
                this.isActive = false;
                this.currentTouchId = null;
                this.centerX = 0;
                this.centerY = 0;
                this.maxRadius = 0;
                this.currentX = 0;
                this.currentY = 0;
                this.movementVector = { x: 0, y: 0 };
                
                this.init();
            }
            
            init() {
                this.joystickBase.addEventListener('touchstart', this.onTouchStart.bind(this), { passive: false });
                document.addEventListener('touchmove', this.onTouchMove.bind(this), { passive: false });
                document.addEventListener('touchend', this.onTouchEnd.bind(this), { passive: false });
                document.addEventListener('touchcancel', this.onTouchEnd.bind(this), { passive: false });
                
                this.joystickBase.addEventListener('mousedown', this.onMouseStart.bind(this), { passive: false });
                document.addEventListener('mousemove', this.onMouseMove.bind(this), { passive: false });
                document.addEventListener('mouseup', this.onMouseEnd.bind(this), { passive: false });
                
                this.updateBaseRect();
                this.setupOrientationHandling();
            }
            
            setupOrientationHandling() {
                let orientationTimeout = null;
                
                const handleOrientationChange = () => {
                    console.log('Joystick: Handling orientation change...');
                    
                    if (orientationTimeout) {
                        clearTimeout(orientationTimeout);
                    }
                    
                    orientationTimeout = setTimeout(() => {
                        this.updateBaseRect();
                        console.log('Joystick: Position updated after orientation change');
                    }, 300);
                };
                
                window.addEventListener('resize', handleOrientationChange);
                window.addEventListener('orientationchange', handleOrientationChange);
                
                if (window.visualViewport) {
                    window.visualViewport.addEventListener('resize', handleOrientationChange);
                }
            }
            
            updateBaseRect() {
                if (!this.joystickBase) return;
                
                try {
                    const rect = this.joystickBase.getBoundingClientRect();
                    this.centerX = rect.left + rect.width / 2;
                    this.centerY = rect.top + rect.height / 2;
                    this.maxRadius = Math.min(rect.width, rect.height) / 2 - 10;
                    
                    if (this.isActive) {
                        this.joystickKnob.style.transform = `translate(${this.currentX - 50}%, ${this.currentY - 50}%)`;
                    }
                } catch (error) {
                    console.warn('Joystick: Error updating base rect:', error);
                }
            }
            
            onTouchStart(e) {
                e.preventDefault();
                if (this.isActive || e.changedTouches.length === 0) return;
                
                const touch = e.changedTouches[0];
                this.startJoystick(touch.clientX, touch.clientY, touch.identifier);
            }
            
            onTouchMove(e) {
                e.preventDefault();
                if (!this.isActive) return;
                
                for (const touch of e.changedTouches) {
                    if (touch.identifier === this.currentTouchId) {
                        this.updateJoystick(touch.clientX, touch.clientY);
                        break;
                    }
                }
            }
            
            onTouchEnd(e) {
                e.preventDefault();
                if (!this.isActive) return;
                
                for (const touch of e.changedTouches) {
                    if (touch.identifier === this.currentTouchId) {
                        this.endJoystick();
                        break;
                    }
                }
            }
            
            onMouseStart(e) {
                e.preventDefault();
                if (this.isActive) return;
                this.startJoystick(e.clientX, e.clientY, 'mouse');
            }
            
            onMouseMove(e) {
                e.preventDefault();
                if (!this.isActive || this.currentTouchId !== 'mouse') return;
                this.updateJoystick(e.clientX, e.clientY);
            }
            
            onMouseEnd(e) {
                e.preventDefault();
                if (!this.isActive || this.currentTouchId !== 'mouse') return;
                this.endJoystick();
            }
            
            startJoystick(clientX, clientY, touchId) {
                this.updateBaseRect();
                this.isActive = true;
                this.currentTouchId = touchId;
                this.updateJoystick(clientX, clientY);
            }
            
            updateJoystick(clientX, clientY) {
                const deltaX = clientX - this.centerX;
                const deltaY = clientY - this.centerY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                let knobX, knobY;
                if (distance <= this.maxRadius) {
                    knobX = deltaX;
                    knobY = deltaY;
                } else {
                    const angle = Math.atan2(deltaY, deltaX);
                    knobX = Math.cos(angle) * this.maxRadius;
                    knobY = Math.sin(angle) * this.maxRadius;
                }
                
                this.currentX = knobX;
                this.currentY = knobY;
                
                this.joystickKnob.style.transform = `translate(${knobX - 50}%, ${knobY - 50}%)`;
                
                this.movementVector.x = knobX / this.maxRadius;
                this.movementVector.y = knobY / this.maxRadius;
                
                this.updateDirectionVisuals();
                this.updateGameInput();
            }
            
            updateDirectionVisuals() {
                const directions = this.joystickBase.querySelectorAll('.joystick-direction');
                directions.forEach(dir => dir.classList.remove('active'));
                
                const deadZone = 0.3;
                if (Math.abs(this.movementVector.x) < deadZone && Math.abs(this.movementVector.y) < deadZone) {
                    return;
                }
                
                const angle = Math.atan2(-this.movementVector.y, this.movementVector.x);
                let degrees = (angle * 180 / Math.PI + 360) % 360;
                
                if (degrees >= 337.5 || degrees < 22.5) {
                    this.joystickBase.querySelector('.joystick-right')?.classList.add('active');
                } else if (degrees >= 22.5 && degrees < 67.5) {
                    this.joystickBase.querySelector('.joystick-up-right')?.classList.add('active');
                } else if (degrees >= 67.5 && degrees < 112.5) {
                    this.joystickBase.querySelector('.joystick-up')?.classList.add('active');
                } else if (degrees >= 112.5 && degrees < 157.5) {
                    this.joystickBase.querySelector('.joystick-up-left')?.classList.add('active');
                } else if (degrees >= 157.5 && degrees < 202.5) {
                    this.joystickBase.querySelector('.joystick-left')?.classList.add('active');
                } else if (degrees >= 202.5 && degrees < 247.5) {
                    this.joystickBase.querySelector('.joystick-down-left')?.classList.add('active');
                } else if (degrees >= 247.5 && degrees < 292.5) {
                    this.joystickBase.querySelector('.joystick-down')?.classList.add('active');
                } else if (degrees >= 292.5 && degrees < 337.5) {
                    this.joystickBase.querySelector('.joystick-down-right')?.classList.add('active');
                }
            }
            
            updateGameInput() {
                ['w', 'a', 's', 'd'].forEach(key => {
                    this.game.keysPressed.delete(key);
                    this.game.joystickKeysPressed.delete(key);
                });
                
                const deadZone = 0.3;
                const threshold = 0.5;
                
                if (Math.abs(this.movementVector.x) > deadZone || Math.abs(this.movementVector.y) > deadZone) {
                    if (this.movementVector.x > threshold) {
                        this.game.keysPressed.add('d');
                        this.game.joystickKeysPressed.add('d');
                    }
                    if (this.movementVector.x < -threshold) {
                        this.game.keysPressed.add('a');
                        this.game.joystickKeysPressed.add('a');
                    }
                    if (this.movementVector.y > threshold) {
                        this.game.keysPressed.add('s');
                        this.game.joystickKeysPressed.add('s');
                    }
                    if (this.movementVector.y < -threshold) {
                        this.game.keysPressed.add('w');
                        this.game.joystickKeysPressed.add('w');
                    }
                }
                
                this.game.keyboardKeysPressed.forEach(key => {
                    this.game.keysPressed.add(key);
                });
            }
            
            endJoystick() {
                this.isActive = false;
                this.currentTouchId = null;
                
                this.joystickKnob.style.transform = 'translate(-50%, -50%)';
                
                this.movementVector.x = 0;
                this.movementVector.y = 0;
                this.currentX = 0;
                this.currentY = 0;
                
                const directions = this.joystickBase.querySelectorAll('.joystick-direction');
                directions.forEach(dir => dir.classList.remove('active'));
                
                ['w', 'a', 's', 'd'].forEach(key => {
                    if (!this.game.keyboardKeysPressed.has(key)) {
                        this.game.keysPressed.delete(key);
                    }
                    this.game.joystickKeysPressed.delete(key);
                });
            }
            
            getMovementVector() {
                return this.movementVector;
            }
        }
        
        // Core Vector3 Class
        class Vector3 {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
            }
            
            add(other) {
                return new Vector3(this.x + other.x, this.y + other.y, this.z + other.z);
            }
            
            subtract(other) {
                return new Vector3(this.x - other.x, this.y - other.y, this.z - other.z);
            }
            
            multiply(scalar) {
                return new Vector3(this.x * scalar, this.y * scalar, this.z * scalar);
            }
            
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            }
            
            normalize() {
                const len = this.length();
                if (len > 0) {
                    return new Vector3(this.x / len, this.y / len, this.z / len);
                }
                return new Vector3(0, 0, 0);
            }
            
            dot(other) {
                return this.x * other.x + this.y * other.y + this.z * other.z;
            }
            
            copy() {
                return new Vector3(this.x, this.y, this.z);
            }
        }
        
        // Character Class
        class Character {
            constructor(pos, color, isPlayer = true, flyingEnabled = true, difficulty = "normal", playerId = 1) {
                this.pos = pos.copy();
                this.color = color;
                this.isPlayer = isPlayer;
                this.playerId = playerId;
                this.flyingEnabled = flyingEnabled;
                this.flying = flyingEnabled;
                
                this.health = 5;
                this.maxHealth = 5;
                
                this.state = "idle";
                this.stateTimer = 0;
                this.attackCooldown = 0;
                this.blockCooldown = 0;
                this.facing = playerId === 1 ? new Vector3(1, 0, 0) : new Vector3(-1, 0, 0);
                this.lockedFacing = null;
                
                this.velocity = new Vector3(0, 0, 0);
                this.moveSpeed = 8.0;
                
                this.attackRange = 5.5;
                this.bodyRadius = 1.0;
                this.hitConnected = false;
                this.damageFlashTimer = 0;
                this.blockFlashTimer = 0;
                this.attackBlockedFlashTimer = 0;
                
                this.attackPressed = false;
                this.blockPressed = false;
                
                this.gravity = 50;
                this.groundLevel = -3;
                
                if (!isPlayer) {
                    this.aiDecisionTimer = 0;
                    this.aiState = "approach";
                    this.aiRetreatTimer = 0;
                    this.aiStrafeDirection = 1;
                    
                    const difficultySettings = {
                        "very_easy": { speed: 0.5, health: 0.6, aggression: 0.2, reaction: 0.3 },
                        "easy": { speed: 0.7, health: 0.8, aggression: 0.4, reaction: 0.5 },
                        "normal": { speed: 1.0, health: 1.0, aggression: 0.6, reaction: 0.7 },
                        "hard": { speed: 1.3, health: 1.4, aggression: 0.8, reaction: 0.85 },
                        "very_hard": { speed: 1.5, health: 1.8, aggression: 0.95, reaction: 0.95 }
                    };
                    
                    const settings = difficultySettings[difficulty] || difficultySettings["normal"];
                    this.aiSpeedMult = settings.speed;
                    this.aiAggression = settings.aggression;
                    this.aiReaction = settings.reaction;
                    
                    this.maxHealth = Math.floor(5 * settings.health);
                    this.health = this.maxHealth;
                }
            }
            
            isInvulnerable() {
                return this.damageFlashTimer > 0 || ["damaged", "falling", "knockback"].includes(this.state);
            }
            
            update(dt, opponent, keysPressed, gameMode, audioManager) {
                dt = Math.min(dt, 1/30);
                
                if (this.stateTimer > 0) {
                    this.stateTimer -= dt;
                    if (this.stateTimer <= 0) {
                        if (["attacking", "blocking", "damaged"].includes(this.state)) {
                            this.state = "idle";
                            this.hitConnected = false;
                            this.lockedFacing = null;
                        } else if (this.state === "knockback") {
                            this.state = "idle";
                            this.velocity = new Vector3(0, 0, 0);
                            this.lockedFacing = null;
                        }
                    }
                }
                
                this.attackCooldown = Math.max(0, this.attackCooldown - dt);
                this.blockCooldown = Math.max(0, this.blockCooldown - dt);
                this.damageFlashTimer = Math.max(0, this.damageFlashTimer - dt);
                this.blockFlashTimer = Math.max(0, this.blockFlashTimer - dt);
                this.attackBlockedFlashTimer = Math.max(0, this.attackBlockedFlashTimer - dt);
                
                if (this.state === "falling") {
                    this.velocity.y -= this.gravity * dt;
                    this.pos = this.pos.add(this.velocity.multiply(dt));
                    
                    if (this.pos.y <= this.groundLevel) {
                        this.pos.y = this.groundLevel;
                        this.velocity = new Vector3(0, 0, 0);
                        this.state = "idle";
                        this.flying = this.flyingEnabled;
                    }
                } else if (this.state === "knockback") {
                    this.pos = this.pos.add(this.velocity.multiply(dt));
                    this.velocity = this.velocity.multiply(Math.pow(0.85, dt * 60));
                } else {
                    if (this.isPlayer && keysPressed) {
                        this.handlePlayerInput(keysPressed, dt, opponent, gameMode, audioManager);
                    } else if (!this.isPlayer) {
                        this.handleAI(dt, opponent, gameMode, audioManager);
                    }
                }
                
                this.pos.x = Math.max(-12, Math.min(12, this.pos.x));
                this.pos.z = Math.max(-12, Math.min(12, this.pos.z));
                if (this.flyingEnabled) {
                    this.pos.y = Math.max(-3, Math.min(12, this.pos.y));
                } else {
                    this.pos.y = -3;
                }
                
                if (this.state === "attacking" && !this.hitConnected) {
                    this.checkAttackHit(opponent, gameMode, audioManager);
                }
            }
            
            handlePlayerInput(keys, dt, opponent, gameMode, audioManager) {
                let moveKeys, attackKeys, blockKeys, flyUpKeys, flyDownKeys;
                
                if (this.playerId === 1) {
                    moveKeys = { 'w': [0, 0, 1], 's': [0, 0, -1], 'a': [-1, 0, 0], 'd': [1, 0, 0] };
                    attackKeys = new Set(['f']);
                    blockKeys = new Set(['g']);
                    flyUpKeys = new Set(['e']);
                    flyDownKeys = new Set(['q']);
                } else {
                    moveKeys = { 'arrowup': [0, 0, 1], 'arrowdown': [0, 0, -1], 'arrowleft': [-1, 0, 0], 'arrowright': [1, 0, 0] };
                    attackKeys = new Set(['k']);
                    blockKeys = new Set(['l']);
                    flyUpKeys = new Set(['i']);
                    flyDownKeys = new Set(['o']);
                }
                
                const isBlockingInput = Array.from(blockKeys).some(key => keys.has(key));
                const canBlock = isBlockingInput && !this.blockPressed && this.blockCooldown <= 0 && 
                               !["blocking", "damaged", "falling", "knockback"].includes(this.state);
                
                if (canBlock) {
                    this.startBlock(audioManager);
                    this.blockPressed = true;
                } else if (!isBlockingInput) {
                    this.blockPressed = false;
                }
                
                if (!["knockback", "falling", "damaged"].includes(this.state)) {
                    let moveVec = new Vector3(0, 0, 0);
                    
                    for (const [key, [x, y, z]] of Object.entries(moveKeys)) {
                        if (keys.has(key)) {
                            moveVec.x += x;
                            moveVec.z += z;
                        }
                    }
                    
                    if (this.flyingEnabled && this.flying) {
                        if (Array.from(flyUpKeys).some(key => keys.has(key))) {
                            moveVec.y += 1;
                        }
                        if (Array.from(flyDownKeys).some(key => keys.has(key))) {
                            moveVec.y -= 1;
                        }
                    }
                    
                    if (moveVec.length() > 0) {
                        moveVec = moveVec.normalize();
                        
                        let speed = this.moveSpeed;
                        if (["attacking", "blocking"].includes(this.state)) {
                            speed *= 0.25;
                        }
                        
                        const newPos = this.pos.add(moveVec.multiply(speed * dt));
                        if (!this.wouldCollide(newPos, opponent)) {
                            this.pos = newPos;
                            if (!this.lockedFacing) {
                                const horizontalMove = new Vector3(moveVec.x, 0, moveVec.z);
                                if (horizontalMove.length() > 0.1) {
                                    this.facing = horizontalMove.normalize();
                                }
                            }
                        }
                    }
                }
                
                const isAttackingInput = Array.from(attackKeys).some(key => keys.has(key));
                const canAttack = isAttackingInput && !this.attackPressed && this.attackCooldown <= 0 && 
                                !["attacking", "damaged", "falling", "knockback"].includes(this.state);
                
                if (canAttack) {
                    this.startAttack(audioManager);
                    this.attackPressed = true;
                } else if (!isAttackingInput) {
                    this.attackPressed = false;
                }
            }
            
            handleAI(dt, opponent, gameMode, audioManager) {
                if (["damaged", "falling", "knockback"].includes(this.state)) {
                    return;
                }
                
                this.aiDecisionTimer -= dt;
                this.aiRetreatTimer = Math.max(0, this.aiRetreatTimer - dt);
                const distance = opponent.pos.subtract(this.pos).length();
                
                if (this.aiDecisionTimer <= 0) {
                    this.aiDecisionTimer = Math.random() * 0.6 + 0.2;
                    if (this.aiRetreatTimer > 0) {
                        this.aiState = "retreat";
                    } else if (distance > 7) {
                        this.aiState = "approach";
                    } else if (distance < 3 && Math.random() < (1.0 - this.aiAggression)) {
                        this.aiState = "retreat";
                        this.aiRetreatTimer = Math.random() * 0.5 + 0.5;
                    } else {
                        if (Math.random() < this.aiAggression) {
                            this.aiState = "combat";
                        } else {
                            this.aiState = "strafe";
                            this.aiStrafeDirection = Math.random() < 0.5 ? 1 : -1;
                        }
                    }
                }
                
                let speed = this.moveSpeed * this.aiSpeedMult;
                if (["attacking", "blocking"].includes(this.state)) {
                    speed *= 0.25;
                }
                
                if (this.aiState === "approach") {
                    const direction = opponent.pos.subtract(this.pos).normalize();
                    const newPos = this.pos.add(direction.multiply(speed * dt));
                    if (!this.wouldCollide(newPos, opponent)) {
                        this.pos = newPos;
                        if (this.state === "idle" && !this.lockedFacing) {
                            this.facing = direction;
                        }
                    }
                } else if (this.aiState === "retreat") {
                    const direction = this.pos.subtract(opponent.pos).normalize();
                    const newPos = this.pos.add(direction.multiply(speed * dt));
                    if (!this.wouldCollide(newPos, opponent)) {
                        this.pos = newPos;
                        if (this.state === "idle" && !this.lockedFacing) {
                            this.facing = opponent.pos.subtract(this.pos).normalize();
                        }
                    }
                } else if (this.aiState === "strafe") {
                    if (this.state === "idle" && !this.lockedFacing) {
                        this.facing = opponent.pos.subtract(this.pos).normalize();
                    }
                    
                    const angle = Math.atan2(this.facing.z, this.facing.x) + this.aiStrafeDirection * 0.8;
                    const strafe = new Vector3(Math.cos(angle), 0, Math.sin(angle));
                    const newPos = this.pos.add(strafe.multiply(speed * 0.7 * dt));
                    if (!this.wouldCollide(newPos, opponent)) {
                        this.pos = newPos;
                    }
                } else if (this.aiState === "combat") {
                    if (this.state === "idle" && !this.lockedFacing) {
                        this.facing = opponent.pos.subtract(this.pos).normalize();
                    }
                    
                    if (distance <= this.attackRange) {
                        if (opponent.state === "attacking" && Math.random() < this.aiReaction && this.blockCooldown <= 0 && this.state === "idle") {
                            this.startBlock(audioManager);
                        } else if (this.attackCooldown <= 0 && Math.random() < this.aiAggression && this.state === "idle") {
                            this.startAttack(audioManager);
                        } else if (this.blockCooldown <= 0 && Math.random() < 0.3 && this.state === "idle") {
                            this.startBlock(audioManager);
                        }
                    }
                }
            }
            
            wouldCollide(newPos, opponent) {
                const distance = newPos.subtract(opponent.pos).length();
                return distance < 2.0;
            }
            
            startAttack(audioManager) {
                this.state = "attacking";
                this.stateTimer = 0.4;
                this.attackCooldown = 0.8;
                this.hitConnected = false;
                this.lockedFacing = this.facing.copy();
                
                if (audioManager) {
                    if (this.isPlayer) {
                        audioManager.playSound('player_attack');
                    } else {
                        audioManager.playSound('enemy_attack');
                    }
                }
            }
            
            startBlock(audioManager) {
                this.state = "blocking";
                this.stateTimer = 0.6;
                this.blockCooldown = 0.8;
                this.lockedFacing = this.facing.copy();
                
                if (audioManager) {
                    if (this.isPlayer) {
                        audioManager.playSound('player_block');
                    } else {
                        audioManager.playSound('enemy_block');
                    }
                }
            }
            
            checkAttackHit(opponent, gameMode, audioManager) {
                if (opponent.isInvulnerable()) {
                    return;
                }
                
                const distance = opponent.pos.subtract(this.pos).length();
                const attackFacing = this.lockedFacing || this.facing;
                const toTarget = opponent.pos.subtract(this.pos).normalize();
                const facingDot = attackFacing.dot(toTarget);
                
                if (distance <= this.attackRange && facingDot > 0.5) {
                    this.hitConnected = true;
                    
                    if (opponent.state === "blocking") {
                        const blockFacing = opponent.lockedFacing || opponent.facing;
                        const toAttacker = this.pos.subtract(opponent.pos).normalize();
                        const blockDot = blockFacing.dot(toAttacker);
                        
                        const blockThreshold = gameMode === "ground" ? 0.4 : -0.2;
                        
                        if (blockDot > blockThreshold) {
                            opponent.blockFlashTimer = 0.5;
                            this.attackBlockedFlashTimer = 0.8;
                            const knockbackDir = this.pos.subtract(opponent.pos).normalize();
                            this.applyKnockback(knockbackDir, 80);
                            
                            if (audioManager) {
                                if (opponent.isPlayer) {
                                    audioManager.playSound('player_block');
                                } else {
                                    audioManager.playSound('enemy_block');
                                }
                            }
                            return;
                        }
                    }
                    
                    const knockbackDir = opponent.pos.subtract(this.pos).normalize();
                    opponent.takeDamage(knockbackDir, audioManager);
                    
                    if (audioManager) {
                        if (this.isPlayer) {
                            audioManager.playSound('player_hit_enemy');
                        } else {
                            audioManager.playSound('enemy_hit_player');
                        }
                    }
                }
            }
            
            takeDamage(knockbackDir, audioManager) {
                this.health -= 1;
                this.state = "damaged";
                this.stateTimer = 0.2;
                this.damageFlashTimer = 1.0;
                
                if (this.flyingEnabled && this.pos.y > this.groundLevel) {
                    this.flying = false;
                    this.state = "falling";
                    this.stateTimer = 0;
                    this.velocity = new Vector3(knockbackDir.x * 40, -8, knockbackDir.z * 40);
                } else {
                    this.applyKnockback(knockbackDir, 60);
                }
                
                if (audioManager) {
                    if (this.isPlayer) {
                        audioManager.playSound('player_take_damage');
                    } else {
                        audioManager.playSound('enemy_take_damage');
                    }
                }
            }
            
            applyKnockback(direction, force) {
                this.velocity = direction.multiply(force);
                this.state = "knockback";
                this.stateTimer = force > 70 ? 1.2 : force > 35 ? 1.0 : 0.8;
            }
            
            getDisplayColor() {
                if (this.damageFlashTimer > 0 && Math.floor(this.damageFlashTimer * 10) % 2) {
                    return "#808080";
                }
                return this.color;
            }
        }
        
        // Main Game Class with Enhanced Android Orientation Protection
        class Game3D {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.stateManager = new StateManager();
                this.audioManager = new AudioManager();
                
                this.gameState = "main_menu";
                this.gameMode = "flying";
                this.multiplayer = false;
                this.difficulty = "normal";
                
                this.cameraPos = new Vector3(0, 10, -35);
                this.cameraAngle = 0;
                
                this.player = null;
                this.enemy = null;
                
                this.keysPressed = new Set();
                this.joystickKeysPressed = new Set();
                this.touchKeysPressed = new Set();
                this.keyboardKeysPressed = new Set();
                
                this.currentStreak = 0;
                this.highScore = parseInt(localStorage.getItem('knightCombatHighScore') || '0');
                this.totalWins = parseInt(localStorage.getItem('knightCombatTotalWins') || '0');
                this.totalLosses = parseInt(localStorage.getItem('knightCombatTotalLosses') || '0');
                
                this.lastTime = performance.now();
                this.gameTime = 0;
                this.running = true;
                
                this.frameCount = 0;
                this.lastFpsTime = performance.now();
                this.fps = 60;
                
                this.victoryNotificationTimer = 0;
                this.roundVictoryDelay = 2.0;
                this.nextEnemyTimer = 0;
                
                this.setupCanvas();
                this.setupEventListeners();
                this.setupOrientationHandling();
                this.setupTouchControls();
                this.setupMenuEventHandlers();
                this.gameLoop();
                
                this.joystickController = new JoystickController(this);
                this.gamepadController = new GamepadController(this);
                
                console.log('Knight Combat 3D initialized with enhanced orientation protection');
            }
            
            setupOrientationHandling() {
                console.log('Setting up enhanced orientation protection for Android...');
                
                let orientationTimeout = null;
                let resizeTimeout = null;
                let isHandlingOrientation = false;
                let lastOrientation = screen.orientation ? screen.orientation.angle : window.orientation || 0;
                
                const handleOrientationChange = (source) => {
                    const currentOrientation = screen.orientation ? screen.orientation.angle : window.orientation || 0;
                    
                    if (currentOrientation === lastOrientation || isHandlingOrientation) {
                        return;
                    }
                    
                    console.log(`Orientation change detected from ${source}: ${lastOrientation}¬∞ ‚Üí ${currentOrientation}¬∞`);
                    lastOrientation = currentOrientation;
                    isHandlingOrientation = true;
                    
                    this.stateManager.saveState(this);
                    
                    if (orientationTimeout) clearTimeout(orientationTimeout);
                    if (resizeTimeout) clearTimeout(resizeTimeout);
                    
                    const attemptRestore = (attempt = 1) => {
                        console.log(`Restoration attempt ${attempt}...`);
                        
                        try {
                            this.resizeCanvas();
                            
                            if (this.joystickController) {
                                this.joystickController.updateBaseRect();
                            }
                            
                            if (this.stateManager.restoreState(this)) {
                                console.log(`Game state restored on attempt ${attempt}`);
                                isHandlingOrientation = false;
                                return;
                            }
                            
                            if (attempt < 3) {
                                setTimeout(() => attemptRestore(attempt + 1), 200);
                            } else {
                                console.log('All restoration attempts failed, using fallback');
                                isHandlingOrientation = false;
                            }
                            
                        } catch (error) {
                            console.error(`Restoration attempt ${attempt} failed:`, error);
                            if (attempt < 3) {
                                setTimeout(() => attemptRestore(attempt + 1), 200);
                            } else {
                                isHandlingOrientation = false;
                            }
                        }
                    };
                    
                    setTimeout(() => attemptRestore(1), 500);
                };
                
                if (screen.orientation) {
                    screen.orientation.addEventListener('change', () => handleOrientationChange('screen.orientation'));
                }
                
                window.addEventListener('orientationchange', () => handleOrientationChange('orientationchange'));
                
                window.addEventListener('resize', () => {
                    if (isHandlingOrientation) return;
                    
                    if (resizeTimeout) clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        console.log('Window resize detected');
                        this.resizeCanvas();
                        
                        if (this.joystickController) {
                            this.joystickController.updateBaseRect();
                        }
                        
                        if (this.stateManager.savedState && this.gameState === "playing") {
                            console.log('Restoring state after resize');
                            this.stateManager.restoreState(this);
                        }
                    }, 200);
                });
                
                if (window.visualViewport) {
                    window.visualViewport.addEventListener('resize', () => {
                        if (!isHandlingOrientation) {
                            handleOrientationChange('visualViewport');
                        }
                    });
                }
                
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible' && this.stateManager.savedState) {
                        console.log('App became visible, checking for restoration need');
                        setTimeout(() => {
                            if (this.gameState === "playing") {
                                this.stateManager.restoreState(this);
                            }
                        }, 100);
                    }
                });
                
                document.addEventListener('pause', () => {
                    console.log('App paused, saving state');
                    this.stateManager.saveState(this);
                });
                
                document.addEventListener('resume', () => {
                    console.log('App resumed, attempting restore');
                    if (this.stateManager.savedState && this.gameState === "playing") {
                        setTimeout(() => this.stateManager.restoreState(this), 200);
                    }
                });
                
                this.stateBackupInterval = setInterval(() => {
                    if (this.gameState === "playing" && this.player && this.enemy) {
                        this.stateManager.saveState(this);
                    }
                }, 5000);
                
                console.log('Enhanced orientation protection active for Android');
            }
            
            setupCanvas() {
                this.resizeCanvas();
            }
            
            resizeCanvas() {
                try {
                    const container = document.getElementById('gameContainer');
                    if (!container) return;
                    
                    const containerWidth = container.clientWidth;
                    const containerHeight = container.clientHeight;
                    
                    let canvasSize = Math.min(containerWidth, containerHeight);
                    
                    if (window.innerWidth <= 768) {
                        canvasSize = Math.min(containerWidth * 0.95, containerHeight * 0.85);
                    }
                    
                    if (Math.abs(this.canvas.width - canvasSize) > 10 || 
                        Math.abs(this.canvas.height - canvasSize) > 10) {
                        
                        this.canvas.width = canvasSize;
                        this.canvas.height = canvasSize;
                        
                        this.scale = canvasSize / 600;
                        this.scaleX = this.scale;
                        this.scaleY = this.scale;
                        
                        console.log(`Canvas resized to ${canvasSize}x${canvasSize}, scale: ${this.scale.toFixed(2)}`);
                    }
                } catch (error) {
                    console.error('Canvas resize error:', error);
                }
            }
            
            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    this.keysPressed.add(key);
                    this.keyboardKeysPressed.add(key);
                    
                    if (['m', 'p'].includes(key)) {
                        if (this.gameState === "playing") {
                            this.togglePause();
                        }
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    const key = e.key.toLowerCase();
                    this.keysPressed.delete(key);
                    this.keyboardKeysPressed.delete(key);
                });
                
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                this.canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
                this.canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
                this.canvas.addEventListener('touchend', (e) => e.preventDefault(), { passive: false });
            }
            
            setupTouchControls() {
                const touchButtons = document.querySelectorAll('.touch-btn[data-key]');
                
                touchButtons.forEach(button => {
                    const key = button.dataset.key;
                    if (!key) return;
                    
                    let isPressed = false;
                    
                    const handleStart = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (!isPressed) {
                            isPressed = true;
                            this.touchKeysPressed.add(key);
                            this.keysPressed.add(key);
                            button.classList.add('active');
                        }
                    };
                    
                    const handleEnd = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (isPressed) {
                            isPressed = false;
                            this.touchKeysPressed.delete(key);
                            this.keysPressed.delete(key);
                            button.classList.remove('active');
                            
                            this.keyboardKeysPressed.forEach(k => {
                                this.keysPressed.add(k);
                            });
                        }
                    };
                    
                    button.addEventListener('touchstart', handleStart, { passive: false });
                    button.addEventListener('touchend', handleEnd, { passive: false });
                    button.addEventListener('touchcancel', handleEnd, { passive: false });
                    
                    button.addEventListener('mousedown', handleStart, { passive: false });
                    button.addEventListener('mouseup', handleEnd, { passive: false });
                    button.addEventListener('mouseleave', handleEnd, { passive: false });
                    button.addEventListener('contextmenu', (e) => e.preventDefault());
                });
            }
            
            setupMenuEventHandlers() {
                const setupButton = (button) => {
                    let isPressed = false;
                    
                    const handleStart = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (!isPressed) {
                            isPressed = true;
                            button.style.background = '#555';
                        }
                    };
                    
                    const handleEnd = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (isPressed) {
                            isPressed = false;
                            button.style.background = '';
                            
                            const action = button.dataset.action;
                            const difficulty = button.dataset.difficulty;
                            
                            if (action === 'startGame') {
                                this.startEndlessGame();
                            } else if (action === 'resumeGame') {
                                this.resumeGame();
                            } else if (action === 'restartGame') {
                                this.restartGame();
                            } else if (action === 'backToMainMenu') {
                                this.backToMainMenu();
                            } else if (action === 'showGamepadInfo') {
                                this.showGamepadInfo();
                            } else if (action === 'exitGame') {
                                this.exitGame();
                            } else if (difficulty) {
                                this.setDifficulty(difficulty);
                            }
                        }
                    };
                    
                    const handleCancel = (e) => {
                        if (isPressed) {
                            isPressed = false;
                            button.style.background = '';
                        }
                    };
                    
                    button.addEventListener('touchstart', handleStart, { passive: false });
                    button.addEventListener('touchend', handleEnd, { passive: false });
                    button.addEventListener('touchcancel', handleCancel, { passive: false });
                    
                    button.addEventListener('mousedown', handleStart, { passive: false });
                    button.addEventListener('mouseup', handleEnd, { passive: false });
                    button.addEventListener('mouseleave', handleCancel, { passive: false });
                    button.addEventListener('contextmenu', (e) => e.preventDefault());
                };
                
                document.querySelectorAll('.menu-btn').forEach(setupButton);
                document.querySelectorAll('.difficulty-btn').forEach(setupButton);
                
                const soundButton = document.getElementById('soundButton');
                const menuButton = document.getElementById('menuButton');
                
                if (soundButton) {
                    let soundPressed = false;
                    const handleSoundStart = (e) => {
                        e.preventDefault();
                        if (!soundPressed) {
                            soundPressed = true;
                            soundButton.style.background = 'rgba(100,100,100,0.8)';
                        }
                    };
                    const handleSoundEnd = (e) => {
                        e.preventDefault();
                        if (soundPressed) {
                            soundPressed = false;
                            soundButton.style.background = '';
                            this.toggleSound();
                        }
                    };
                    soundButton.addEventListener('touchstart', handleSoundStart, { passive: false });
                    soundButton.addEventListener('touchend', handleSoundEnd, { passive: false });
                    soundButton.addEventListener('touchcancel', () => { soundPressed = false; soundButton.style.background = ''; }, { passive: false });
                    soundButton.addEventListener('mousedown', handleSoundStart, { passive: false });
                    soundButton.addEventListener('mouseup', handleSoundEnd, { passive: false });
                    soundButton.addEventListener('mouseleave', () => { soundPressed = false; soundButton.style.background = ''; }, { passive: false });
                }
                
                if (menuButton) {
                    let menuPressed = false;
                    const handleMenuStart = (e) => {
                        e.preventDefault();
                        if (!menuPressed) {
                            menuPressed = true;
                            menuButton.style.background = 'rgba(100,100,100,0.8)';
                        }
                    };
                    const handleMenuEnd = (e) => {
                        e.preventDefault();
                        if (menuPressed) {
                            menuPressed = false;
                            menuButton.style.background = '';
                            this.togglePause();
                        }
                    };
                    menuButton.addEventListener('touchstart', handleMenuStart, { passive: false });
                    menuButton.addEventListener('touchend', handleMenuEnd, { passive: false });
                    menuButton.addEventListener('touchcancel', () => { menuPressed = false; menuButton.style.background = ''; }, { passive: false });
                    menuButton.addEventListener('mousedown', handleMenuStart, { passive: false });
                    menuButton.addEventListener('mouseup', handleMenuEnd, { passive: false });
                    menuButton.addEventListener('mouseleave', () => { menuPressed = false; menuButton.style.background = ''; }, { passive: false });
                }
            }
            
            saveProgress() {
                try {
                    localStorage.setItem('knightCombatHighScore', this.highScore.toString());
                    localStorage.setItem('knightCombatTotalWins', this.totalWins.toString());
                    localStorage.setItem('knightCombatTotalLosses', this.totalLosses.toString());
                } catch (e) {
                    console.warn('Failed to save progress to localStorage:', e);
                }
            }
            
            togglePause() {
                if (this.gameState === "playing") {
                    this.gameState = "paused";
                    document.getElementById('menu').classList.remove('hidden');
                    this.showPauseMenu();
                    this.keysPressed.clear();
                    this.keyboardKeysPressed.clear();
                    if (this.gamepadController) {
                        this.gamepadController.gamepadState.player1.menu = { open: false, select: false, back: false };
                        this.gamepadController.gamepadState.player2.menu = { open: false, select: false, back: false };
                    }
                } else if (this.gameState === "paused") {
                    this.gameState = "playing";
                    document.getElementById('menu').classList.add('hidden');
                }
            }
            
            exitGame() {
                if (confirm('Exit Knight Combat 3D?')) {
                    if (window.flutter_inappwebview) {
                        window.flutter_inappwebview.callHandler('exitApp');
                        return;
                    }
                    
                    if (window.cordova && navigator.app) {
                        navigator.app.exitApp();
                        return;
                    }
                    
                    if (window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.App) {
                        window.Capacitor.Plugins.App.exitApp();
                        return;
                    }
                    
                    if (window.electronAPI) {
                        window.electronAPI.closeApp();
                        return;
                    }
                    
                    if ('serviceWorker' in navigator) {
                        caches.keys().then(cacheNames => {
                            return Promise.all(
                                cacheNames.map(cacheName => caches.delete(cacheName))
                            );
                        }).then(() => {
                            window.close();
                        });
                    } else {
                        window.close();
                    }
                    
                    setTimeout(() => {
                        window.location.href = 'about:blank';
                    }, 1000);
                }
            }
            
            showMainMenu() {
                document.getElementById('mainMenuButtons').classList.remove('hidden');
                document.getElementById('pauseMenuButtons').classList.add('hidden');
                document.getElementById('menuButton').style.display = 'none';
                
                if (this.gamepadController) {
                    this.gamepadController.updateMenuItems();
                }
            }
            
            showPauseMenu() {
                document.getElementById('mainMenuButtons').classList.add('hidden');
                document.getElementById('pauseMenuButtons').classList.remove('hidden');
                document.getElementById('menuButton').style.display = 'block';
                
                if (this.gamepadController) {
                    this.gamepadController.updateMenuItems();
                }
            }
            
            startEndlessGame() {
                this.gameState = "playing";
                this.gameMode = "flying";
                this.multiplayer = false;
                
                this.stateManager.clearState();
                
                this.currentStreak = 0;
                this.nextEnemyTimer = 0;
                this.victoryNotificationTimer = 0;
                
                document.getElementById('menu').classList.add('hidden');
                
                this.player = new Character(new Vector3(-5, -3, 0), "#FF0000", true, true, this.difficulty, 1);
                this.spawnNewEnemy();
                
                this.player.facing = new Vector3(1, 0, 0);
                this.enemy.facing = new Vector3(-1, 0, 0);
                
                let inputInfo = "Keyboard";
                if (this.gamepadController && this.gamepadController.hasGamepad()) {
                    inputInfo += " + Gamepad";
                }
                
                document.getElementById('gameMode').textContent = `ENDLESS SURVIVAL - Flying Combat (${inputInfo})`;
                this.updateGameStatus();
                this.updateHealthBars();
                
                document.getElementById('menuButton').style.display = 'block';
                document.getElementById('victoryNotification').classList.remove('show');
            }
            
            continueEndlessGame() {
                this.nextEnemyTimer = 0;
                this.victoryNotificationTimer = 0;
                
                this.spawnNewEnemy();
                
                this.player.facing = new Vector3(1, 0, 0);
                this.enemy.facing = new Vector3(-1, 0, 0);
                
                this.player.pos = new Vector3(-5, -3, 0);
                this.player.state = "idle";
                this.player.velocity = new Vector3(0, 0, 0);
                this.player.flying = true;
                
                this.updateGameStatus();
                this.updateHealthBars();
                
                document.getElementById('victoryNotification').classList.remove('show');
            }
            
            spawnNewEnemy() {
                let enemyDifficulty = this.difficulty;
                
                if (this.currentStreak >= 20) {
                    enemyDifficulty = "very_hard";
                } else if (this.currentStreak >= 15) {
                    enemyDifficulty = "hard";
                } else if (this.currentStreak >= 10) {
                    enemyDifficulty = this.difficulty === "very_easy" ? "easy" : 
                                    this.difficulty === "easy" ? "normal" :
                                    this.difficulty === "normal" ? "hard" : "very_hard";
                } else if (this.currentStreak >= 5) {
                    enemyDifficulty = this.difficulty === "very_easy" ? "easy" : "normal";
                }
                
                this.enemy = new Character(new Vector3(5, -3, 0), "#0000FF", false, true, enemyDifficulty, 2);
            }
            
            setDifficulty(difficulty) {
                this.difficulty = difficulty;
                
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                const targetBtn = document.querySelector(`[data-difficulty="${difficulty}"]`);
                if (targetBtn) {
                    targetBtn.classList.add('active');
                }
            }
            
            showGamepadInfo() {
                const connectedCount = this.gamepadController.getConnectedCount();
                const hasGamepad = this.gamepadController.hasGamepad();
                
                let message = `GAMEPAD STATUS:\n\n`;
                message += `Connected Controllers: ${connectedCount}\n`;
                
                if (hasGamepad) {
                    message += `Player 1 Controller: Active\n`;
                } else {
                    message += `Player 1 Controller: None\n`;
                }
                
                message += `\nCONTROLLER MAPPING (Multiple Options for Flying!):\n`;
                
                message += `\nMENU NAVIGATION:\n`;
                message += `‚Ä¢ Left Stick/D-Pad: Navigate menus\n`;
                message += `‚Ä¢ A Button: Select menu item\n`;
                message += `‚Ä¢ B Button: Back/Cancel\n`;
                message += `‚Ä¢ Start: Open/Close menu\n`;
                
                message += `\nENDLESS SURVIVAL CONTROLS:\n`;
                message += `‚Ä¢ Left Stick/D-Pad: Movement\n`;
                message += `‚Ä¢ A Button: Attack\n`;
                message += `‚Ä¢ B Button: Block\n`;
                
                message += `\nFLYING CONTROLS (Multiple Options!):\n`;
                message += `PRIMARY FLYING CONTROLS:\n`;
                message += `‚Ä¢ Y Button: Fly Up (Primary)\n`;
                message += `‚Ä¢ X Button: Fly Down (Primary)\n`;
                message += `\nALTERNATIVE FLYING CONTROLS:\n`;
                message += `‚Ä¢ Right Trigger (RT): Fly Up\n`;
                message += `‚Ä¢ Left Trigger (LT): Fly Down\n`;
                message += `‚Ä¢ Right Stick Up/Down: Fly Up/Down\n`;
                message += `‚Ä¢ Right Bumper (RB): Fly Up\n`;
                message += `‚Ä¢ Left Bumper (LB): Fly Down\n`;
                message += `‚Ä¢ D-pad Up: Fly Up (while moving)\n`;
                message += `‚Ä¢ D-pad Down: Fly Down (while moving)\n`;
                message += `‚Ä¢ Left Stick Click (L3): Fly Down\n`;
                message += `‚Ä¢ Right Stick Click (R3): Fly Up\n`;
                
                if (connectedCount === 0) {
                    message += `\nCONTROLLER CONNECTION:\n`;
                    message += `1. Connect controller via USB or Bluetooth\n`;
                    message += `2. Press any button to wake controller\n`;
                    message += `3. For Xbox: Press Xbox button if not detected\n`;
                    message += `4. For PlayStation: Press PS button\n`;
                    message += `5. Try reconnecting USB cable if wireless fails\n`;
                } else {
                    message += `\nFLYING SYSTEM STATUS:\n`;
                    message += `‚Ä¢ Multiple flying control methods active\n`;
                    message += `‚Ä¢ Auto-detection for unknown buttons enabled\n`;
                    message += `‚Ä¢ Trigger axis detection improved\n`;
                    message += `‚Ä¢ Right stick flying controls enabled\n`;
                    
                    message += `\nIF FLYING DOESN'T WORK:\n`;
                    message += `1. Try ALL the flying control options above\n`;
                    message += `2. Enable debug mode to see button mapping\n`;
                    message += `3. Look for "FLY UP/DOWN activated!" in console (F12)\n`;
                    message += `4. Try different controller profiles/modes\n`;
                    message += `5. Test each button individually to find working ones\n`;
                }
                
                const enableDebug = confirm(message + '\n\nEnable ENHANCED debug mode to see all controller input?\nThis will help identify which buttons work for flying.');
                
                if (enableDebug) {
                    this.gamepadController.enableDebugMode();
                    console.log('ENHANCED FLYING DEBUG MODE ENABLED');
                    console.log('========================================');
                    console.log('INSTRUCTIONS FOR TESTING FLYING:');
                    console.log('1. Start the Endless Survival game');
                    console.log('2. Press EVERY button on your controller');
                    console.log('3. Look for "FLY UP activated!" or "FLY DOWN activated!" messages');
                    console.log('4. Try all stick movements and triggers');
                    console.log('5. Note which buttons work for flying');
                    console.log('========================================');
                    
                    setTimeout(() => {
                        this.gamepadController.disableDebugMode();
                        console.log('Debug mode auto-disabled after 2 minutes');
                    }, 120000);
                } else {
                    this.gamepadController.disableDebugMode();
                }
            }
            
            resumeGame() {
                if (this.gameState === "paused") {
                    this.gameState = "playing";
                    document.getElementById('menu').classList.add('hidden');
                }
            }
            
            restartGame() {
                this.startEndlessGame();
            }
            
            backToMainMenu() {
                this.gameState = "main_menu";
                this.showMainMenu();
                document.getElementById('menuButton').style.display = 'none';
                document.getElementById('victoryNotification').classList.remove('show');
            }
            
            toggleSound() {
                if (this.audioManager) {
                    const muted = this.audioManager.toggleMute();
                    document.getElementById('soundButton').textContent = muted ? 'üîá' : 'üîä';
                }
            }
            
            showVictoryNotification() {
                const notification = document.getElementById('victoryNotification');
                const continuingText = document.getElementById('continuingText');
                
                continuingText.textContent = `Health: ${this.player.health}/${this.player.maxHealth} | Next enemy in ${Math.ceil(this.nextEnemyTimer)}s`;
                notification.classList.add('show');
                this.victoryNotificationTimer = this.roundVictoryDelay;
            }
            
            updateVictoryNotification() {
                if (this.victoryNotificationTimer > 0) {
                    const continuingText = document.getElementById('continuingText');
                    continuingText.textContent = `Health: ${this.player.health}/${this.player.maxHealth} | Next enemy in ${Math.ceil(this.nextEnemyTimer)}s`;
                }
            }
            
            updateGameStatus() {
                const statusText = `Current: ${this.currentStreak} | High Score: ${this.highScore} | Total Wins: ${this.totalWins} | Losses: ${this.totalLosses}`;
                document.getElementById('gameStatus').textContent = statusText;
            }
            
            update(dt) {
                dt = Math.min(dt, 1/30);
                this.gameTime += dt;
                
                if (this.gameState !== "playing") return;
                
                if (this.victoryNotificationTimer > 0) {
                    this.victoryNotificationTimer -= dt;
                    this.nextEnemyTimer -= dt;
                    this.updateVictoryNotification();
                    
                    if (this.victoryNotificationTimer <= 0) {
                        this.continueEndlessGame();
                    }
                    return;
                }
                
                this.player.update(dt, this.enemy, this.keysPressed, this.gameMode, this.audioManager);
                this.enemy.update(dt, this.player, null, this.gameMode, this.audioManager);
                
                if (this.player.health <= 0) {
                    this.totalLosses++;
                    this.currentStreak = 0;
                    this.gameState = "game_over";
                    this.audioManager.playSound('player_defeat');
                    this.saveProgress();
                    
                    setTimeout(() => {
                        this.gameState = "main_menu";
                        document.getElementById('menu').classList.remove('hidden');
                        document.getElementById('menuButton').style.display = 'none';
                        this.showMainMenu();
                    }, 2000);
                } else if (this.enemy.health <= 0) {
                    this.currentStreak++;
                    this.totalWins++;
                    
                    if (this.currentStreak > this.highScore) {
                        this.highScore = this.currentStreak;
                    }
                    
                    this.saveProgress();
                    this.audioManager.playSound('round_victory');
                    
                    this.nextEnemyTimer = this.roundVictoryDelay;
                    this.showVictoryNotification();
                }
                
                this.updateHealthBars();
                this.updateGameStatus();
            }
            
            updateHealthBars() {
                if (this.player) {
                    const player1Pct = Math.max(0, (this.player.health / this.player.maxHealth) * 100);
                    document.getElementById('player1Health').style.width = player1Pct + '%';
                }
                
                if (this.enemy) {
                    const player2Pct = Math.max(0, (this.enemy.health / this.enemy.maxHealth) * 100);
                    document.getElementById('player2Health').style.width = player2Pct + '%';
                }
            }
            
            project3D(point) {
                const camX = point.x - this.cameraPos.x;
                const camY = point.y - this.cameraPos.y;
                const camZ = point.z - this.cameraPos.z;
                
                const cosA = Math.cos(this.cameraAngle);
                const sinA = Math.sin(this.cameraAngle);
                
                const newX = camX * cosA - camZ * sinA;
                const newZ = camX * sinA + camZ * cosA;
                
                if (newZ <= 0.1) return null;
                
                const fov = 350 * this.scale;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                const screenX = (newX / newZ) * fov + centerX;
                const screenY = (-camY / newZ) * fov + centerY;
                
                return { x: screenX, y: screenY, z: newZ };
            }
            
            drawBox(center, width, height, depth, color) {
                const hw = width / 2, hh = height / 2, hd = depth / 2;
                
                const vertices = [
                    new Vector3(center.x - hw, center.y - hh, center.z - hd),
                    new Vector3(center.x + hw, center.y - hh, center.z - hd),
                    new Vector3(center.x + hw, center.y + hh, center.z - hd),
                    new Vector3(center.x - hw, center.y + hh, center.z - hd),
                    new Vector3(center.x - hw, center.y - hh, center.z + hd),
                    new Vector3(center.x + hw, center.y - hh, center.z + hd),
                    new Vector3(center.x + hw, center.y + hh, center.z + hd),
                    new Vector3(center.x - hw, center.y + hh, center.z + hd),
                ];
                
                const projected = [];
                for (const v of vertices) {
                    const p = this.project3D(v);
                    if (!p) return;
                    projected.push(p);
                }
                
                const faces = [
                    [0, 1, 2, 3], [4, 5, 6, 7], [0, 1, 5, 4],
                    [2, 3, 7, 6], [0, 3, 7, 4], [1, 2, 6, 5],
                ];
                
                const faceDepths = faces.map(face => {
                    const avgZ = face.reduce((sum, i) => sum + vertices[i].z, 0) / 4;
                    return { depth: avgZ, face: face };
                });
                
                faceDepths.sort((a, b) => b.depth - a.depth);
                
                for (const { face } of faceDepths) {
                    this.ctx.fillStyle = color;
                    this.ctx.strokeStyle = "white";
                    this.ctx.lineWidth = Math.max(1, this.scale);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(projected[face[0]].x, projected[face[0]].y);
                    for (let i = 1; i < face.length; i++) {
                        this.ctx.lineTo(projected[face[i]].x, projected[face[i]].y);
                    }
                    this.ctx.closePath();
                    this.ctx.fill();
                    this.ctx.stroke();
                }
            }
            
            drawCharacter(char) {
                const color = char.getDisplayColor();
                const parts = [];
                
                parts.push({ z: char.pos.z, draw: () => this.drawBox(char.pos, 1.5, 2, 0.8, color) });

                const neckPos = char.pos.add(new Vector3(0, 1.2, 0));
                const neckHeight = char.isPlayer && char.playerId === 1 ? 1.0 : 1.2;
                parts.push({ z: neckPos.z, draw: () => this.drawBox(neckPos, 1.0, neckHeight, 1.0, color) });

                const headPos = char.pos.add(new Vector3(0, 2.5, 0));
                const headSize = char.isPlayer && char.playerId === 1 ? 1.2 : 1.0;
                parts.push({ z: headPos.z, draw: () => this.drawBox(headPos, headSize, headSize, headSize, color) });
                
                const leftArm = char.pos.add(new Vector3(-0.9, 1.0, 0));
                const rightArm = char.pos.add(new Vector3(0.9, 1.0, 0));
                parts.push({ z: leftArm.z, draw: () => this.drawBox(leftArm, 0.6, 1.4, 0.6, color) });
                parts.push({ z: rightArm.z, draw: () => this.drawBox(rightArm, 0.6, 1.4, 0.6, color) });
                
                const leftLeg = char.pos.add(new Vector3(-0.4, -2, 0));
                const rightLeg = char.pos.add(new Vector3(0.4, -2, 0));
                parts.push({ z: leftLeg.z, draw: () => this.drawBox(leftLeg, 0.7, 2, 0.7, color) });
                parts.push({ z: rightLeg.z, draw: () => this.drawBox(rightLeg, 0.7, 2, 0.7, color) });
                
                const weaponFacing = char.lockedFacing || char.facing;
                let swordColor = "#FFD700";
                if (char.isPlayer && char.playerId === 2) {
                    swordColor = "#00FFFF";
                } else if (!char.isPlayer) {
                    swordColor = "#FF6347";
                }
                
                if (char.attackBlockedFlashTimer > 0 && Math.floor(char.attackBlockedFlashTimer * 12) % 2) {
                    swordColor = "#FF0000";
                }
                
                const globalAnimationCycle = this.gameTime * 2.5;
                const subtleBob = Math.sin(globalAnimationCycle) * 0.15;
                
                if (char.state === "attacking") {
                    const swordPos = char.pos.add(weaponFacing.multiply(2.5)).add(new Vector3(0, 1.0 + subtleBob, 0));
                    if (Math.abs(weaponFacing.x) > Math.abs(weaponFacing.z)) {
                        parts.push({ z: swordPos.z, draw: () => this.drawBox(swordPos, 5.0, 0.3, 0.3, swordColor) });
                    } else {
                        parts.push({ z: swordPos.z, draw: () => this.drawBox(swordPos, 0.3, 0.3, 5.0, swordColor) });
                    }
                } else if (char.state === "blocking") {
                    const shieldColor = char.blockFlashTimer > 0 ? "#9370DB" : "#4169E1";
                    const shieldPos = char.pos.add(weaponFacing.multiply(1.8)).add(new Vector3(0, 0.5 + subtleBob, 0));
                    if (Math.abs(weaponFacing.x) > Math.abs(weaponFacing.z)) {
                        parts.push({ z: shieldPos.z, draw: () => this.drawBox(shieldPos, 0.4, 3.0, 2.5, shieldColor) });
                        const swordPos = char.pos.add(weaponFacing.multiply(1.6)).add(new Vector3(0, 0.8 + subtleBob, 0));
                        parts.push({ z: swordPos.z, draw: () => this.drawBox(swordPos, 0.3, 0.3, 3.5, swordColor) });
                    } else {
                        parts.push({ z: shieldPos.z, draw: () => this.drawBox(shieldPos, 2.5, 3.0, 0.4, shieldColor) });
                        const swordPos = char.pos.add(weaponFacing.multiply(1.6)).add(new Vector3(0, 0.8 + subtleBob, 0));
                        parts.push({ z: swordPos.z, draw: () => this.drawBox(swordPos, 3.5, 0.3, 0.3, swordColor) });
                    }
                } else {
                    const animationCycle = this.gameTime * 3;
                    const swordBob = Math.sin(animationCycle) * 0.2;
                    const swordPos = char.pos.add(char.facing.multiply(1.2)).add(new Vector3(0, 2.0 + swordBob + subtleBob, 0));
                    parts.push({ z: swordPos.z, draw: () => this.drawBox(swordPos, 0.3, 4.0, 0.3, swordColor) });
                }
                
                return parts.sort((a, b) => b.z - a.z);
            }
            
            drawEnvironment() {
                this.ctx.strokeStyle = "#333333";
                this.ctx.lineWidth = Math.max(1, this.scale * 0.5);
                
                for (let i = -18; i <= 18; i += 2) {
                    const p1 = this.project3D(new Vector3(i, -3, -18));
                    const p2 = this.project3D(new Vector3(i, -3, 18));
                    if (p1 && p2) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(p1.x, p1.y);
                        this.ctx.lineTo(p2.x, p2.y);
                        this.ctx.stroke();
                    }
                    
                    const p3 = this.project3D(new Vector3(-18, -3, i));
                    const p4 = this.project3D(new Vector3(18, -3, i));
                    if (p3 && p4) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(p3.x, p3.y);
                        this.ctx.lineTo(p4.x, p4.y);
                        this.ctx.stroke();
                    }
                }
                
                this.ctx.strokeStyle = "#666666";
                this.ctx.lineWidth = Math.max(2, this.scale * 2);
                
                const floorBoundaries = [
                    [new Vector3(-18, -3, -18), new Vector3(18, -3, -18)],
                    [new Vector3(-18, -3, 18), new Vector3(18, -3, 18)],
                    [new Vector3(-18, -3, -18), new Vector3(-18, -3, 18)],
                    [new Vector3(18, -3, -18), new Vector3(18, -3, 18)]
                ];
                
                for (const [p1, p2] of floorBoundaries) {
                    const proj1 = this.project3D(p1);
                    const proj2 = this.project3D(p2);
                    if (proj1 && proj2) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(proj1.x, proj1.y);
                        this.ctx.lineTo(proj2.x, proj2.y);
                        this.ctx.stroke();
                    }
                }
                
                const verticalEdges = [
                    [new Vector3(-18, -3, -18), new Vector3(-18, 15, -18)],
                    [new Vector3(18, -3, -18), new Vector3(18, 15, -18)],
                    [new Vector3(18, -3, 18), new Vector3(18, 15, 18)],
                    [new Vector3(-18, -3, 18), new Vector3(-18, 15, 18)]
                ];
                
                for (const [p1, p2] of verticalEdges) {
                    const proj1 = this.project3D(p1);
                    const proj2 = this.project3D(p2);
                    if (proj1 && proj2) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(proj1.x, proj1.y);
                        this.ctx.lineTo(proj2.x, proj2.y);
                        this.ctx.stroke();
                    }
                }
                
                const topBoundaries = [
                    [new Vector3(-18, 15, -18), new Vector3(18, 15, -18)],
                    [new Vector3(-18, 15, 18), new Vector3(18, 15, 18)],
                    [new Vector3(-18, 15, -18), new Vector3(-18, 15, 18)],
                    [new Vector3(18, 15, -18), new Vector3(18, 15, 18)]
                ];
                
                for (const [p1, p2] of topBoundaries) {
                    const proj1 = this.project3D(p1);
                    const proj2 = this.project3D(p2);
                    if (proj1 && proj2) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(proj1.x, proj1.y);
                        this.ctx.lineTo(proj2.x, proj2.y);
                        this.ctx.stroke();
                    }
                }
            }
            
            render() {
                this.ctx.fillStyle = "#000000";
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.gameState === "playing" || this.gameState === "paused") {
                    this.drawEnvironment();
                    
                    if (this.player && this.enemy) {
                        const playerParts = this.drawCharacter(this.player);
                        const enemyParts = this.drawCharacter(this.enemy);
                        
                        const allParts = [...playerParts, ...enemyParts];
                        allParts.sort((a, b) => b.z - a.z);
                        
                        for (const part of allParts) {
                            part.draw();
                        }
                    }
                } else if (this.gameState === "game_over") {
                    this.ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    this.ctx.fillStyle = this.enemy.health <= 0 ? "gold" : "red";
                    this.ctx.font = `${Math.min(48 * this.scale, 48)}px Arial`;
                    this.ctx.textAlign = "center";
                    
                    if (this.enemy.health <= 0) {
                        this.ctx.fillText("ENEMY DEFEATED!", this.canvas.width / 2, this.canvas.height / 2 - 40);
                        this.ctx.fillStyle = "white";
                        this.ctx.font = `${Math.min(24 * this.scale, 24)}px Arial`;
                        this.ctx.fillText(`Streak: ${this.currentStreak}`, this.canvas.width / 2, this.canvas.height / 2);
                    } else {
                        this.ctx.fillText("GAME OVER!", this.canvas.width / 2, this.canvas.height / 2 - 40);
                        this.ctx.fillStyle = "white";
                        this.ctx.font = `${Math.min(24 * this.scale, 24)}px Arial`;
                        this.ctx.fillText(`Final Streak: ${this.currentStreak}`, this.canvas.width / 2, this.canvas.height / 2);
                        if (this.currentStreak === this.highScore && this.currentStreak > 0) {
                            this.ctx.fillStyle = "gold";
                            this.ctx.fillText("NEW HIGH SCORE!", this.canvas.width / 2, this.canvas.height / 2 + 30);
                        }
                    }
                }
            }
            
            gameLoop() {
                if (!this.running) return;
                
                const now = performance.now();
                const dt = Math.min((now - this.lastTime) / 1000, 1/30);
                this.lastTime = now;
                
                this.frameCount++;
                if (now - this.lastFpsTime >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsTime = now;
                }
                
                this.update(dt);
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }
            
            destroy() {
                console.log('Cleaning up game resources...');
                this.running = false;
                
                if (this.stateBackupInterval) {
                    clearInterval(this.stateBackupInterval);
                    this.stateBackupInterval = null;
                }
                
                if (this.stateManager) {
                    this.stateManager.clearState();
                }
                
                if (this.gamepadController) {
                    this.gamepadController.destroy();
                }
                
                this.keysPressed.clear();
                this.joystickKeysPressed.clear();
                this.touchKeysPressed.clear();
                this.keyboardKeysPressed.clear();
                
                console.log('Game cleanup completed');
            }
        }
        
        // Game Initialization
        let game;
        
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Knight Combat 3D starting with enhanced orientation protection...');
            
            document.getElementById('touchControls').classList.remove('hidden');
            document.getElementById('rightControls').classList.remove('hidden');
            
            try {
                game = new Game3D();
                game.showMainMenu();
                
                game.setDifficulty('normal');
                document.getElementById('menuButton').style.display = 'none';
                
                if (game.gamepadController) {
                    setTimeout(() => {
                        game.gamepadController.updateMenuItems();
                    }, 100);
                }
                
                console.log('Knight Combat 3D initialized successfully');
                window.game = game;
                
            } catch (error) {
                console.error('Failed to initialize Knight Combat 3D:', error);
                alert('Failed to start game. Please refresh and try again.');
            }
        });
        
        window.addEventListener('error', (e) => {
            console.error('Global error:', e.error);
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled promise rejection:', e.reason);
        });
    </script>
</body>
</html>
